Manual Gentoo Linux
===================
v0.2, 2013-10-21
:Author:      Sven Vermeulen
:doctype:     book
:description: platforma amd64
:imagesdir:   assets/images
:homepage:    http://gentoo-land.org/

Translatori: Stoian Ovidiu, Mihai Tene și Alin Dobre

Corecturi: Ștefan Suciu
Versiuni alternative (HTML, PDF și EPUB): Ștefan Suciu

== Capitolul 1

=== Despre instalarea Gentoo

==== Introducere

Bine ați venit!

În primul rând vă urăm, bun venit în lumea minunată Gentoo. Sunteți pe
cale să descoperiți lumea flexibilității și performanței. Odată ce vă
veți hotărî să instalați Gentoo Linux, procedeul de instalare vă
permite o foarte mare flexibilitate în alegerea modalității de
instalare, care poate fi compilarea întregului sistem de la început
sau doar instalând binarele. Aveți posibilitatea de a alege
componentele de sistem cum sunt încărcătorul de sistem (bootloader),
logger-ele etc.

Gentoo este o meta-distribuție modernă și foarte rapidă, ce are o
structură flexibilă. Gentoo este construit în jurul conceptului
programelor libere (free software) și pune la dispoziția
utilizatorilor toate resursele. Portage, sistemul de administrare al
pachetelor utilizat de Gentoo, este scris în limbajul de programare
Python, utilizatorii având acces la codul sursă și putând modifica
sursele în funcție de necesitățile proprii. Sistemul de pachete Gentoo
utilizează codul sursă al programelor (deși oferă și suport pentru
binare precompilate), iar configurarea Gentoo se efectuează prin
editarea directă a fișierelor de configurare (fișiere de tip text). Cu
alte cuvinte este un sistem deschis. Este foarte important să
înțelegeți că posibilitatea de a alege face ca Gentoo să
funcționeze. Noi nu vă forțăm să faceți nimic din ceea ce vă
displace. În cazul în care nu credeți acest lucru, vă rugăm să ne
scrieți un bugreport.

*Cum este structurat procesul de instalare?*

- După pasul 1, vă aflați în mediul de lucru și sunteți pregătit pentru
instalarea Gentoo.

- După pasul 2, conexiunea la internet este pregătită pentru
instalarea Gentoo.

- După pasul 3, discul dur (hard disk-ul) este pregătit pentru a
găzdui Gentoo.

- După pasul 4, mediul de instalare este pregătit și puteți utiliza
chroot pentru integrarea în noul mediu.

- După pasul 5, pachetele de bază, ce sunt la fel pentru toate
sistemele Gentoo, vor fi instalate.

- După pasul 6, kernel-ul Linux va fi compilat.

- După pasul 7, vor fi completate majoritatea fișierelor de
configurare Gentoo.

- După pasul 8, utilitarele de sistem necesare (pe care le puteți
alege dintr-o listă completă) sunt instalate.

- După pasul 9, aplicația încărcătorul de sistem (bootloader) aleasă a
fost instalată, configurată și sunteți logați în noua instalare
Gentoo.

- După pasul 10, noul dumneavoastră mediu Gentoo, va fii gata de
explorat.

Gentoo Linux vă permite o foarte mare flexibilitate în alegere, pe
care o să încercăm să o explicăm atât din punct de vedere al punctelor
forte cât și al punctelor slabe. O să continuăm cu un set de opțiuni
implicite, identificate cu ”Implicite: ” în titlu. Celelalte opțiuni
sunt marcate cu ”Alternativ: ”. Să nu considerați că opțiunile
implicite sunt cele recomandate. În orice caz, sunt ceea ce credem că
cei mai mulți dintre utilizatori vor folosi.

În anumite cazuri puteți opta pentru soluții marcate ca ”Opțional: ”,
care nu sunt obligatorii în timpul instalării Gentoo. Aveți grijă la
anumite opțiuni care pot depinde de alte opțiuni ce au fost alese sau
ce vor depinde de anumiți pași ce vor fi executați în prealabil sau
după alegerea opțiunii și pe care o să-i menționăm în documentația de
față.

*Care sunt opțiunile?*

Gentoo poate fi instalat în diferite moduri. Aveți posibilitatea de a
descărca și instala Gentoo Linux de pe unul din mediile de instalare
CD disponibile, de pe un alt CD boot-abil (cum este Knoppix), boot-ând
din rețea etc.

Acest document acoperă modalitatea de instalare
utilizând un mediu de instalare CD Gentoo sau în unele cazuri
boot-area din rețea. Această modalitate de instalare presupune că
doriți să instalați ultima versiune a fiecărui pachet. Dacă doriți să
efectuați o instalare fără rețea, va trebui să consultați Manualele
Gentoo ce conțin instrucțiunile de instalare pentru un mediu fără
rețea.

NOTE: Pentru o instalare de pe un alt CD decât cel oficial, incluzând
discuri optice non-Gentoo, vă rugăm să citiți ghidul de instalare
alternativă.

Dacă doriți o instalare din rețea, ar trebui să citiți Manualele
Gentoo, ce conțin pașii de instalare dintr-o rețea.

De asemenea, notați faptul că dacă doriți să utilizați GRP (Gentoo
Reference Platform, o colecție de pachete precompilate destinate
utilizării imediate după o instalare Gentoo), trebuie să urmați
instrucțiunile din Manualele Gentoo.

Pentru instrucțiuni despre alte metode de instalare, vă rugăm să
consultați Ghidul de Instalare Alternativă. De asemenea, vă oferim
un document cu Sfaturi și Trucuri pentru Instalarea Gentoo care de
asemenea vă poate fi de folos. În cazul în care considerați că
instrucțiunile de instalare curente sunt prea elaborate, puteți
utiliza Ghidul de Instalare Rapidă, disponibil pe pagina noastră de
Resurse de Documentare, dacă arhitectura dumnevoastră dispune de un
asemenea document.

De asemenea aveți mai multe posibilități: puteți compila întregul
sistem de la bază sau a utiliza un mediu precompilat care permite o
instalare foarte rapidă și desigur puteți utiliza metoda de instalare
intermediară unde nu este necesară compilarea întregului sistem ci
doar a unei părți din sistemul de bază care vine semi-precompilat.

*Probleme?*

Dacă ați găsit o eroare sau neconcordanță în procesul de instalare
(sau documentația de instalare) vă rugăm să vizitați sistemul de
urmărire al bug-urilor și să verificați dacă eroarea descoperită de
către dumneavoastră este cunoscută. Dacă nu a fost semnalată creați un
raport cu defecte de funcționare (bug-raport) pentru a permite
corectarea erorilor într-un timp cât mai scurt.

Notați că, deși documentul pe care îl citiți acum este specific
arhitecturii, va conține de asemenea și referințe către alte
arhitecturi. Aceasta se întâmplă deoarece multe părți ale Manualului
Gentoo utilizează cod sursă ce este comun pentru toate arhitecturile
(pentru a evita multiplicarea eforturilor și irosirea resurselor de
dezvoltare). O să încercăm să minimizăm aceste informații pentru a
evita confuzia.

Dacă pe parcursul procesului de instalare întâmpinați greutăți și nu
sunteți sigur de natura problemei care poate fi problemă-utilizator
sau problemă-software și răspunsul nu-l puteți găsi în documentația de
față, sunteți invitați să vă alăturați la canalul de discuții oficial
Gentoo join #gentoo de pe irc.freenode.net, unde cu siguranță veți
putea găsi răspuns la problemele și întrebările ce vă
interesează. Bineînțeles, sunteți binevenit și în alte situații.

Dacă aveți întrebări referitoare la Gentoo, vizitați Întrebări
frecvente despre Gentoo Linux, pe care le puteți găsi la Documentații
Gentoo. De asemenea puteți consulta FAQs de pe forumuri.

== Capitolul 2

=== Alegerea Mediului de Instalare Corect

==== Necesități hardware

===== Introducere

Înainte de a începe, avem nevoie să cunoaștem componentele hardware ce
sunt suportate de Gentoo Linux pentru o instalare reușită.

[width="50%",cols="5,10"]
.Necesități Hardware
|===
|Procesor
|AMD64 sau ulterior

|Memorie
|256 MOcteți

|Spațiu pe disc
|2.5 GOcteți (excluzând spațiul swap)

|Spațiu swap
|Cel puțin 512 MOcteți
|===

Ar trebui să verificați Gentoo AMD64 Project Page înainte să începeți.

==== Mediile Gentoo Installation CD

Mediile Gentoo Installation CD sunt încărcabile (boot-abile) și conțin
mediu Gentoo complet funcțional. Acestea vă permit să încărcați
(boot-ați) de pe CD. În timpul procesului de încărcare (boot-are),
sistemul va încerca identificarea tuturor componentelor hardware și
instalarea driverelor specifice. Mentenanța acestora este efectuată de
către dezvoltatorii Gentoo.  Toate mediile Installation CD vă permit
să boot-ați, să puteți configura rețeaua, inițializa partițiile și să
începeți instalarea Gentoo de pe Internet.

*Mediul Gentoo Installation CD Minimal*

Mediul Installation CD Minimal este denumit
__install-amd64-minimal-<release>.iso__ și ocupă numai 200 MOcteți de
spațiu pe disc. Puteți utiliza acest mediu Installation CD pentru a
instala Gentoo, dar întotdeauna cu o conexiune la Internet activă.

[width="80%",cols="5,10",options="header"]
|===
|Mediul Installation CD Minimal
|Pro și Contra

|*+*
|Ușor de descărcat din cauza dimensiunilor reduse

|*-*
|Nu conține arhiva +stage3+, versiunea snapshot pentru Portage,
pachetele necesare pentru instalarea GRP, de aceea nu există
posibilitatea instalării fără conexiune la internet
|===

*Mediul Gentoo Installer LiveDVD*

Puteți utiliza acest mediu Installation DVD pentru a instala Gentoo,
și chiar pentru a instala Gentoo fără a avea o conexiune activă la
Internet. La aproximativ șase luni Comunitatea Gentoo pune la
dispoziție o imagine DVD a sistemului de operare Gentoo ce poate fi
instalată și ea pe hard disk. Instrucțiunile de instalare pot fi puțin
diferite deoarece acest manual are ca scop instalarea de pe mediul
Gentoo Installation CD Minimal. În orice caz puteți să ajungeți în
contul root invocând sudo su sau sudo -i în terminal.

[width="80%",cols="5,10",options="header"]
|===
|Mediul Installer LiveCD
|Pro și Contra

|*+*
|Conține toate pachetele necesare pentru o funcționare completă a
sistemului. Facilitează instalarea Gentoo Linux fără suport
pentru rețea.

|*-*
|Mult de descărcat
|===

*Arhiva tar stage3*

Un fișier tar stage3 este o arhivă ce conține un mediul minimal
Gentoo, potrivit pentru a continua instalarea Gentoo utilizând
instrucțiunile din acest manual. Anterior, Manual Gentoo descria
instalarea utilizând una din cele trei arhive tar stage. În timp ce
Gentoo încă mai oferă arhivele tar stage1 și stage2, modalitatea de
instalare oficială utilizează o arhivă tar stage3.  Dacă sunteți
interesat să utilizați un fișier tar stage1 sau stage2, vă rugăm să
consultați documentul cu Întrebări Frecvente în Gentoo, secțiunea
Cum Instalez Gentoo Utilizând O Arhivă Tar Stage1 sau Stage2?

Arhivele stage3 pot fi descărcate din directorul
_releases/amd64/autobuilds/current-stage3/_ de pe oricare din
Mirror-urile Oficiale Gentoo și nu sunt oferite pe mediul Live CD.

==== Descărcarea, scrierea și încărcarea unui mediu Installation CD

*Descărcarea și scrierea mediului Installation CD*

Ați ales instalarea Gentoo utilizând un mediu Installation CD. Vom
începe prin a descărca și a scrie mediul Installation CD ales. Am
tratat anterior mediile Installation CD disponibile, dar de unde le
putem descărca?

Puteți descărca unul din mediile Installation CD disponibile (și dacă
doriți, Packages CD, de asemenea) de pe unul din site-urile
mirror. Mediile Installation CD se găsesc în directorul
__releases/amd64/autobuilds/current-iso__.

În director veți găsi fișierele cu extensia ISO. Aceste fișiere sunt
imagini exacte ale CD-urilor originale care pot fi scrise pe
DVD-R(W)/DVD+R(W), CD-R(W).  În caz că vă întrebați dacă fișierul
descărcat este corupt sau nu, îi puteți verifica suma de control SHA-2
oferită de noi (cum ar fi
__install-amd64-minimal-<release>.iso.DIGESTS__).  Puteți verifica
suma de control SHA-2 utilizând utilitarul sha512sum pentru
Linux/Unix, sau File Checksum Tool pentru Windows.

O altă metodă de verificare a integrității imaginii Live CD-ului
descărcat, este utilizarea GnuPG pentru verificarea semnăturii
criptografice ce v-o oferim (fișierul ce are terminația .asc).
Descărcați fișierul ce conține semnătura și obțineți cheia publică.

.Obținerea cheii publice
[source,bash]
----
# gpg --keyserver subkeys.pgp.net --recv-keys 96D8BF6D 2D182910 17072058
----

Acum, verificați semnătura criptografică.

.Verificarea semnăturii criptografice
[source,bash]
----
# gpg --verify <fisierul cu semnatura> <fisierul iso descarcat>
----

Pentru a scrie imaginile ISO pe CD-uri trebuie să selectați
raw-burning. Felul cum activați această opțiune depinde foarte mult de
platformă. Vom trata aici cdrecord și K3B; pentru mai multe informații
consultați documentul despre Întrebări Frecvente despre Gentoo.

- Cu K3B, selectați Tools > Burn CD Image. Apoi veți putea localiza
fișierul ISO din locația ’Image to Burn’. Pentru finalizare dați click
pe Start.

- Pentru cdrecord, trebuie doar să tastați cdrecord dev=/dev/sr0
<fișierul iso descărcat> (înlocuiți /dev/sr0 cu calea către unitatea
dvs. CD-RW)

*Încărcarea mediului Installation CD*

IMPORTANT: Consultați cu atenție întreaga subsecțiune înainte de a
continua, pentru că, probabil nu veți mai avea această posibilitate
înainte de a continua ulterior.

După ce ați scris mediul Installation CD a venit timpul să îl încărcăm
(boot-ăm). Scoateți CD-ul (dacă este prezent) din unitatea CD-ROM,
reporniți PC-ul și intrați în BIOS. Această operație se poate efectua
apăsând una din tastele DEL, F1 sau ESC, depinzând de producătorul
BIOS- ului instalat. În meniul din BIOS schimbați ordinea încărcării
(boot-ării) unităților de disc, și anume setați CD-ROM-ul ca primul
disc de pe care să se înceapă citirea inițializării sistemului de
operare. În majoritatea cazurilor submeniul pentru schimbarea ordinii
de boot se poate găsi în meniul ”CMOS Setup”. Dacă nu activați
opțiunea de boot de pe CD-ROM după inițializarea BIOS-ului, PC-ul va
încărca sistemul de operare de pe hard-disc ignorând unitatea CD-ROM.

Introduceți DVD/CD-ul în unitatea CD-ROM și reporniți PC-ul. După ce
CD-ul a inițiat procedura de boot va apărea un prompt de
boot. Apăsând tasta Enter procesul de încărcare (tr. en: boot) al
CD-ului va continua cu opțiunile prestabilite pentru inițializarea
sistemului, sau puteți boot-a mediul Installation CD cu opțiuni
suplimentare prin specificarea unei imagini de kernel, urmată de
opțiuni de încărcare (tr. en: boot) și apoi apăsarea Enter.

Specificarea Kernel-ului? Mediul Installation CD vă oferă mai multe
imagini de kernel.  Kernel-ul implicit este gentoo. Alte imagini de
kernel sunt specifice unor anume necesități hardware și variantele
_-nofb_ ce dezactivează opțiunea framebuffer.

În continuare veți regăsi o prezentare scurtă a imaginilor de kernel
disponibile:

[width="70%",cols="2,6",options="header"]
|===
|Kernel
|Descriere

|gentoo
|Kernel implicit cu suport pentru sisteme multiprocesor

|gentoo-nofb
|La fel ca și în cazul gentoo, dar fără suport pentru framebuffer

|memtest86
| Va încărca utilitarul pentru testarea memoriei RAM de erori
|===

Puteți utiliza și opțiuni de kernel. Ele reprezintă setări opționale
ce le puteți (dez)activa în funcție de necesități. Lista de opțiuni
prezentată mai jos va apare la apăsarea tastei F2 în meniu de
încărcare (bootscreen).


[width="70%",cols="<.^2,10"]
|===
|*acpi=on*
|Încarcă suportul pentru ACPI și de asemenea pornește daemon-ul la
boot când rulam de pe CD. Aveți nevoie de acesta doar dacă sistemul
dumneavoastră are nevoie de ACPI pentru a funcționa.  Acesta nu este
necesar pentru suportul Hyperthreading.

|*acpi=off*
|Dezactivează suportul ACPI. Acesta este necesar pentru hardware mai
vechi și este imperios necesar să folosim APM. Acest parametru
(opțiune) va dezactiva suportul Hyperthreading din procesorul
dumneavoastră.

|*console=X*
|Aceasta stabilește modul de accesare a CD-ului. Prima opțiune este
dispozitivul, cel mai frecvent ttyS0 pe arhitectura x86, urmat de
orice tip de conexiune, care sunt separate prin virgula.  Opțiunile
inițiale sunt 9600,8,n,1.

|*dmraid=X*
|Vă permite să trimiteți spre sistemul device-mapper RAID o
opțiune. Aceasta opțiune trebuie sa fie scrisă intre ghilimele.

|*doapm*
|Încarcă modulul APM. De asemenea este nevoie sa dezactivați acpi în
cazul în care folosiți aceasta opțiune.

|*dopcmcia*
|Pornește serviciul pcmcia pentru dispozitivele cdroms PCMCIA

|*doscsi*
|Încarcă suportul pentru controlere SCSI. De asemenea este necesar
pentru a putea boota majoritatea deviceurilor USB.

|*sda=stroke*
|Vă permite să partiționați întregul harddisk, chiar și atunci când
BIOS-ul nu poate manipula discuri mari.

|*ide=nodma*
|Forțează dezactivarea DMA pentru dispozitivele IDE cu probleme de
funcționare

|*noapic*
|Dezactivează apic (Advanced Programmable Interrupt Controller) acesta
fiind prezent în plăcile de bază noi. Este cunoscut faptul că poate
provoca probleme pe hardware vechi.

|*nodetect*
|Dezactivează întreaga autodetectare realizată de CD, inclusiv
autodetectarea și probarea DHCP. Această opțiune este bună în cazul în
care facem debugging în cazul unui driver cu probleme sau a unui CD.

|*nodhcp*
|Dezactivează DHCP pentru rețelele detectate. Este folositoare în
cazul rețelelor cu adresa ip statică.

|*nodmraid*
|Dezactivează suportul pentru RAID.

|*nofirewire*
|Dezactivează încărcarea modulelor Firewire. Este necesară în cazul în
care hardwareul Fireware vă creează probleme atunci când bootați de pe
CD.

|*nogpm*
|Dezactivează suportul pentru mouse în consola (tty).

|*nohotplug*
|Dezactivează încarcarea scripturilor de inițializare hotplug și
coldplug. Această opțiune este bună în cazul în care facem debugging
în cazul unui driver cu probleme sau a unui CD.

|*nokeymap*
|Dezactivează selecția definițiilor de taste pentru tastaturile cu
dispunere non-us.

|*nolapic*
|Dezactivează APIC din kernel.

|*nosata*
|Dezactivează încărcarea modulului disponibil pentru Serial ATA.  Este
folositoare atunci când avem probleme cu sistemul SATA.

|*nosmp*
|Dezactivează SMP, sau Symmetric Multiprocessing, pentru kernelurile
cu suport SMP.

|*nosound*
|Dezactivează suportul pentru sunet și setările pentru volum. Este
folositoare atunci când hardwareul pentru sunet cauzeaza probleme.

|*nousb*
|Dezactivează încărcarea modulului usb din initrd, dezactivează
hotplug.

|*slowusb*
|Adauga pauze mai lungi în procesul de bootare pentru unitati optice
pe usb (USB CDROMs).
|===

Acum încărcați (boot-ați) de pe CD, selectați un kernel (dacă nu
sunteți mulțumit de imaginea gentoo implicită) cu opțiunile
dorite. În exemplul de mai jos, vă prezentăm modalitatea de a încărca
(boot-a) imaginea de kernel gentoo cu dopcmcia ca parametru:

[source,bash]w
.Boot-area mediului Installation CD
----
# boot: gentoo dopcmcia
----

Apoi, veți observa imaginea de încărcare (boot) și bara de
progres. Dacă instalați Gentoo pe un sistem cu o tastatură non-US,
apăsați imediat Alt+F1 pentru a comuta în modul informativ și urmați
promptul. Dacă nu se efectuează nici o selecție în 10 secunde, cea
implicită (tastatura US) va fi luată în considerare și procesul de
încărcare (boot) va continua. Odată ce procesul de încărcare (boot) a
fost finalizat veți fi logat în mediul ”Live” al Gentoo Linux ca
”root”, modul super user. În consola curentă puteți observa promptul
root (”#”) și puteți comuta între alte console utilizând combinațiile
de taste Alt-F2, Alt-F3 și Alt-F4. Pentru a reveni la consola inițială
utilizați combinația de taste Alt-F1.

Acum, continuați cu Configurarea Suplimentară pentru Componentele
Hardware.

*Configurarea suplimentară pentru componentele hardware*

Mediul Gentoo Installation CD, în timp ce încarcă (boot-ează),
încearcă să identifice automat toate componentele hardware din sistem
și încarcă modulele de kernel ce fac posibilă accesarea acestor
resurse hardware. Dar, sunt și cazuri când încărcarea automată nu este
efectuată pentru modulele necesare. În cazul în care autodetectarea
componentelor PCI a eșuat în cazul unor componente ale sistemului
dumneavoastră, vor trebui încărcate manual modulele de kernel
necesare. În următorul exemplu o să încercam încărcarea modulului
8139too (ce oferă suport pentru un anumit tip de plăci de rețea):

.Încărcarea modulelor de kernel
[source,bash]
----
# modprobe 8139too
----


Dacă aveți nevoie de suport PCMCIA, va trebui să porniți scriptul de
inițializare pcmcia:

[source,bash]
.Pornirea script-ului de inițializare PCMCIA
----
# /etc/init.d/pcmcia start
----

Opțional: Optimizarea performanțelor discului dur (Hard-Disk-ului)

Dacă sunteți un utilizator avansat, puteți optimiza performanța
discului dur (hard disk-ului), utilizând hdparm. În combinație cu
opțiunile -tT puteți testa performanțele hard discului (executați
testul de mai multe ori pentru a avea o imagine cât mai precisă a
vitezei a discului dur).

[source,bash]
.Testarea peformanței discului
----
# hdparm -tT /dev/sda
----

Pentru optimizare, puteți utiliza
oricare din exemplele de mai jos (sau experimenta cu propriile
optimizări) ce utilizează /dev/sda ca disc (substituiți cu discul
dumneavoastră.):


[source,bash]
.Activarea DMA:
----
# hdparm -d 1 /dev/hda
----

[source,bash]
.Opțiuni sigure de creștere a performaței:
----
# hdparm -d 1 -A 1 -m 16 -u 1 -a 64 /dev/hda
----

Opțional: Conturi de Utilizator

Dacă doriți să permiteți accesul utilizatorilor externi la mediul de
instalare Gentoo Linux, sau utilizați chat-ul irssi fără drepturi de
root (pentru un nivel mai ridicat al securității), trebuie să creați
utilizatori separați și este necesară modificarea parolei de root.
Pentru a schimba parola root, rulați utilitarul passwd.

[source,bash]
.Schimbarea parolei de root
----
# passwd
New password: (Enter your new password)
Re-enter password: (Re-enter your password)
----

Pentru crearea unui nou cont de utilizator trebuie să introducem
denumirea contului și parola ce va fi asociată contului nou
creat. Pentru aceasta vom utiliza comenzile useradd și passwd. În
exemplu de mai jos o să cream un user numit ”john”.


[source,bash]
.Crearea unui cont de utilizator
----
# useradd -m -G users john
# passwd john
New password: (Enter john's password)
Re-enter password: (Re-enter john's password)
----

Puteți efectua login în noul cont creat din root, utilizând comanda
su:

[source,bash]
.Comutarea la alt utilizator
----
# su - john
----

Opțional: Vizualizarea Documentației în Timpul Instalării

Dacă doriți consultarea documentației de pe CD, puteți rula imediat
aplicația links ce vă permite vizualizarea documentației:

[source,bash]
.Vizualizarea documentației de pe CD
----
# links /mnt/cdrom/docs/html/index.html
----

Pentru cei ce doresc să utilizeze documentația oficială în limba
engleză este recomandat să utilizeze Manualul Gentoo aflat online,
deoarece este mult mai recent decât cel oferit pe CD.  De asemenea pot
utiliza aplicația links, dar numai după ce au terminat capitolul
despre Configurarea Rețelei (în caz contrar nu vor putea accesa
internetul pentru a putea consulta online Manualul Gentoo).

[source,bash]
.Accesarea Documentației Online
----
# links http://www.gentoo.org/doc/en/handbook/handbook-amd64.xml
----

Puteți reveni la terminalul inițial apăsând combinația de taste
Alt-F1.

Opțional: Pornirea serviciului SSH

Dacă vreți ca alți utilizatori să poată accesa procesul de instalare
Gentoo Linux (posibil, să vă ajute să instalați Gentoo, sau chiar să
îl instaleze pentru dumneavoastră.), va trebui să le creați conturi de
utilizator sau chiar sa le oferiți parola de root (doar dacă aveți
încredere deplină în acel utilizator).

Pentru a inițializa serviciul SSH, executați comanda de mai jos:

[source,bash]
.Pornirea serviciului SSH
----
# /etc/init.d/sshd start
----

Pentru a putea utiliza serviciul ssh trebuie configurat accesul la
rețea. Continuați cu capitolul despre Configurarea Rețelei.

== Capitolul 3

=== Configurarea rețelei

==== Detectarea automată a rețelei

Poate funcționa pur și simplu?

Dacă sistemul dumneavoastră este conectat la o rețea deservită de un
server DHCP, este foarte probabil ca suportul de rețea să fie deja
configurat automat. Dacă este așa, puteți beneficia de avantajul
comenzilor incluse pe mediul Installation CD cum ar fi ssh, scp, ping,
irssi, wget și links, alături de altele.

Dacă rețeaua a fost configurată automat, comanda /sbin/ifconfig ar
trebui să afișeze informații despre alte câteva interfețe în afara
lo, cum ar fi eth0:

[source,bash]
----
# /sbin/ifconfig
eth0  Link encap:Ethernet HWaddr 00:50:BA:8F:61:7A
inet addr:192.168.0.2 Bcast:192.168.0.255 Mask:255.255.255.0
inet6 addr: fe80::50:ba8f:617a/10 Scope:Link
UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
RX packets:1498792 errors:0 dropped:0 overruns:0 frame:0
TX packets:1284980 errors:0 dropped:0 overruns:0 carrier:0
collisions:1984 txqueuelen:100
RX bytes:485691215 (463.1 Mb) TX bytes:123951388 (118.2 Mb)
Interrupt:11 Base address:0xe800
----

Opțional: Configurare proxy

Dacă aveți acces la Internet prin intermediul unui proxy, va trebui să
setați informațiile necesare în timpul instalării. Este foarte ușor
să specificați folosirea unui proxy: trebuie doar să definiți o
variabilă ce conține informațiile despre serverul folosit.

În majoritatea cazurilor, este suficient să
definiți variabilele folosind adresa serverului proxy.  Ca exemplu, o
să presupunem că aceasta este proxy.gentoo.org și portul este 8080.

Definirea serverelor proxy

....
(Pentru traficul HTTP)  # export http_proxy="http://proxy.gentoo.org:8080"
(Pentru traficul FTP)   # export ftp_proxy="ftp://proxy.gentoo.org:8080"
(Pentru traficul RSYNC) # export RSYNC_PROXY="proxy.gentoo.org:8080"
....

Dacă serverul proxy folosit necesită autentificare cu nume și parolă,
trebuie să folosiți următoarea sintaxă pentru definirea
variabilelor:

....
Adăugarea nume/parolă la variabilele ce definesc proxy

http://username:password@server
....


În funcție de mediul de pe care ați ales să instalați Gentoo puteți
continua sau nu fără rețea (și acces Internet).

În general aveți nevoie de a configura rețeaua (și accesul la
Internet). Totuși, Gentoo vă permite și instalarea fără o conexiune la
Internet, acest lucru fiind posibil numai cu ajutorul LiveCD-urilor
Gentoo Universal.

De ce am nevoie de rețea?

Instalând Gentoo de pe Internet veți avea toate actualizările la
zi. Veți avea o instalare bazată pe cel mai recent Portage (care este
o colecție de pachete furnizate împreună cu instrumentele necesare
administrării lor). Acesta este de altfel motivul pentru care
instalarea de pe Internet este preferată. Totuși, unele persoane nu
pot sau nu vor să instaleze Gentoo pe un sistem conectat la Internet.

Dacă sunteți în această situație atunci sunteți nevoiți să folosiți
LiveCD-urile Gentoo Universal. Acest LiveCD include cod sursă, o
versiune completă a Portage și instrumentele necesare instalării unui
sistem de bază Gentoo, și chiar mai mult. Această metodă are însă
prețul ei: nu veți avea ultimele versiuni ale programelor instalate.

Dacă vreți să urmați instalarea fără a fi conectați la internet și
doriți să folosiți un CD Universal Gentoo LiveCD, săriți peste
restul acestui capitol și continuați cu Pregătirea Discurilor.
Altfel, continuați cu secțiunile despre configurarea suportului de
rețea ce urmează.

Testarea rețelei

Ați putea încerca să dați __ping__ în serverele de nume ale
provider-ului dumneavoastră (cele scrise în __/etc/resolv.conf__) și
apoi într-un site la alegere, doar pentru a vă asigura că pachetele
dumneavoastră ajung pe internet și rezolvarea numelor funcționează
corect, etc.

[source,bash]
.Exemplu de testare a rețelei
----
$ ping -c 3 www.yahoo.com
----

Dacă puteți utiliza, acum, rețeaua, puteți sări peste restul acestei
secțiuni și continua cu Pregătirea Discurilor. Dacă nu, citiți mai
departe.

==== Configurarea automată a rețelei

Dacă rețeaua nu funcționează imediat,
unele medii de instalare vă permit să folosiți net- setup (pentru
rețele obișnuite sau wireless) sau pppoe-setup (pentru conexiuni ADSL)
sau pptp (pentru conexiuni PPTP disponibilă doar pe arhitectura x86,
amd64, alpha, ppc și ppc64).  Dacă suportul dumneavoastră de instalare
nu conține nici un instrument (mai sus menționat) sau rețeaua nu
funcționează încă, continuați cu Configurarea Manuală a Rețelei.

- Pentru conexiuni obișnuite continuați cu Implicit: Folosirea net-setup
- Pentru conexiuni ADSL continuați cu Alternativ: Folosirea PPP
- Pentru conexiuni PPTP continuați cu Alternativ: Folosirea PPTP

Implicit: Folosirea net-setup

Cea mai simplă cale de a configura rețeaua dacă aceasta nu s-a efectuat în
mod automat este să rulați scriptul __net-setup__:

[source,bash]
.Rularea scriptului
----
# net-setup eth0
----

__net-setup__ vă va interoga despre câteva lucruri referitoare la
rețea. La final ar trebui să aveți o rețea funcțională. Testați
rețeaua în modul descris anterior. Dacă testele sunt pozitive,
felicitări! Acum sunteți gata să instalați Gentoo. Săriți peste restul
acestei secțiuni și continuați cu Pregătirea Discurilor.

Dacă rețeaua dumneavoastră tot nu este funcțională, continuați cu
Configurarea Manuală a Rețelei.

Alternativ: Folosirea PPP

Presupunând că aveți nevoie de PPPoE pentru a vă conecta la internet,
mediul Installation CD (orice versiune) a simplificat lucrurile pentru
dumneavoastră incluzând scriptul ppp. Folosiți scriptul pppoe-setup
pentru a configura conexiunea. Va trebui să specificați care anume
interfață de rețea este conectată la modemul ADSL, numele și parola,
ip-urile serverelor de nume (DNS) și dacă doriți sau nu un firewall
minim.

[source,bash]
.Folosirea ppp
----
# pppoe-setup
----

Dacă ceva nu a funcționat, verificați din nou dacă ați introdus numele
și parola corecte uitându-vă în __/etc/ppp/pap-secrets__ sau
__/etc/ppp/chap-secrets__ și asigurați-vă că ați specificat corect
interfața folosită pentru conectare. Dacă interfața de rețea nu
există, va trebui să încărcați modulul corespunzător. În acest caz ar
trebui să continuați cu Configurarea Manuală a Rețelei unde este
explicat modul de încărcare a modulelor necesare.  Dacă totul este în
regulă, continuați cu Pregătirea Discurilor.

Alternativ: Folosirea PPTP

Dacă aveți nevoie de PPTP, puteți folosi scriptul __pptpclient__
disponibil pe mediul Installation CD. Dar, mai întâi, trebuie să vă
asigurați că aveți o configurație corectă. Editați
__/etc/ppp/pap-secrets__ sau __/etc/ppp/chap-secrets__ astfel încât
acestea să conțină combinația corectă nume/parolă:

[source,bash]
.Editare /etc/ppp/chap-secrets
----
# nano -w /etc/ppp/chap-secrets
----

Ajustăm, dacă este necesar __/etc/ppp/options.pptp__:

[source,bash]
.Editare /etc/ppp/options.pptp
----
# nano -w /etc/ppp/options.pptp
----

Când totul este în regulă, doar rulați pptp (împreună cu opțiunile pe
care nu le-ați putut seta în options.pptp) pentru a vă conecta la
server:

[source,bash]
.Conectarea la un server dial-in
----
# pptp <server ip>
----

Acum continuați cu Pregătirea Discurilor.

==== Configurarea manuală a rețelei

Încărcarea modulelor potrivite

La încărcarea (boot-area) de pe mediul Installation CD, se încearcă
detectarea tuturor dispozitivelor hardware și încărcarea modulelor
kernel (driver-e) necesare acestora. În marea majoritate a cazurilor,
LiveCD-ul face o treabă foarte bună (detectând aproape tot). Totuși,
în unele cazuri, este posibil să nu fie încărcate automat unele module
necesare.

Dacă net-setup sau pppoe-setup eșuează, atunci este posibil ca placa
de rețea să nu fi fost autodetectată. Aceasta presupune ca
dumneavoastră să încărcați manual modulele kernel corespunzătoare.

Pentru a afla ce module sunt disponibile pentru rețea, folosiți ls:

[source,bash]
.Căutarea modulelor disponibile
----
# ls /lib/modules/`uname -r`/kernel/drivers/net
----

Dacă ați găsit driver-ul necesar plăcii de rețea, folosiți
__modprobe__ pentru a-l încărca:

[source,bash]
.Folosirea modprobe pentru a încărca un modul kernel
----
# modprobe pcnet32
----
(Ca exemplu, noi încărcăm modulul pcnet32 )

Pentru a verifica dacă placa dumneavoastră de rețea este detectată,
folosiți __ifconfig__. O placă de rețea detectată ar trebui să
furnizeze un rezultat de genul:

[source,bash]
.Testarea disponibilității plăcii de rețea, rezultat în caz de succes
----
# ifconfig eth0
Link encap:Ethernet HWaddr FE:FD:00:00:00:00
BROADCAST NOARP MULTICAST MTU:1500 Metric:1
RX packets:0 errors:0 dropped:0 overruns:0 frame:0
TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0
RX bytes:0 (0.0 b) TX bytes:0 (0.0 b)
----

Dacă totuși primiți următoarea eroare, placa de rețea nu a fost
detectată:

[source,bash]
.Testarea disponibilității plăcii de rețea, rezultat în caz de eșec
----
# ifconfig eth0 eth0: error fetching interface information: Device not found
----

Dacă aveți mai multe plăci de rețea în sistemul dumneavoastră acestea
sunt numite eth0, eth1 etc. Asigurați-vă că placa pe care doriți să o
folosiți funcționează împreună cu acest document. Noi vom presupune că
este folosită placa corespunzător și amintiți-vă să folosiți numele
corespunzător eth0.

Presupunând că acum placa de rețea este detectată, puteți reîncerca
net-setup sau pppoe- setup (acum ar trebui să meargă), dar pentru cei
cărora le place calea dificilă o să vă explicăm cum să configurați
manual rețeaua.  Selectați una din următoarele secțiuni în funcție de
tipul rețelei:

- Folosirea DHCP pentru alocarea automată a IP-ului;
- Pregătirea pentru acces Wireless dacă aveți o placă wireless;
- Terminologia utilizată în rețelistică explică ceea ce trebuie să știți despre rețele;
- Folosirea __ifconfig__ și __route__ explică cum să setați manual rețeaua.

Folosirea DHCP

DHCP (Dynamic Host Configuration Protocol) face
posibilă obținerea în mod automat a informațiilor necesare
configurării rețelei (adresa IP, netmask, adresa broadcast, gateway,
servere de nume etc.). Aceasta funcționează numai dacă în rețeaua
dumneavoastră există un server DHCP (sau provider-ul dumneavoastră de
internet vă furnizează serviciul DHCP). Pentru ca placa de rețea să
fie configurată automat folosiți __dhcpcd__:

[source,bash]
.Folosirea dhcpcd
----
# dhcpcd eth0
----

Unii administratori de rețea vă impun să folosiți pentru mașina
dumneavoastră numele de host și domeniu furnizate de serverul DHCP. În
acest caz, folosiți:

[source,bash] ---- # dhcpcd -HD eth0 ---- Dacă totul a fost în regulă
(încercați ping la câteva adrese internet, de exemplu Google), atunci
aveți totul setat și sunteți gata pentru a continua. Săriți peste
restul acestei secțiuni și continuați cu Pregătirea Discurilor.

Pregătirea pentru acces Wireless

NOTE: Suportul pentru comanda __iwconfig__ este disponibil doar pentru
mediile Installation CD pentru arhitecturile x86, amd64 și
ppc. Puteți, însă, să faceți să funcționeze placa wireless urmând
instrucțiunile din proiectul __linux-wlan-ng__.

Dacă folosiți o placă wireless (802.11), trebuie să
efectuați toate setările necesare înainte de a putea să
continuați. Pentru a vedea setările curente ale plăcii dumneavoastră,
puteți folosi __iwconfig__.  Rularea __iwconfig__ poate afișa ceva de genul:

[source,bash]
.Listarea setărilor curente pentru placa wireless
----
# iwconfig eth0 eth0
IEEE 802.11-DS ESSID:”GentooNode” Mode:Managed Frequency:2.442GHz
Access Point: 00:09:5B:11:CC:F2 Bit Rate:11Mb/s Tx-Power=20 dBm
Sensitivity=0/65535 Retry limit:16 RTS thr:off Fragment thr:off Power
Management:off Link Quality:25/10 Signal level:-51 dBm Noise
level:-102 dBm Rx invalid nwid:5901 Rx invalid crypt:0 Rx invalid
frag:0 Tx excessive retries:237 Invalid misc:350282 Missed beacon:84
----

NOTE: Unele plăci wireless pot avea numele wlan0 sau ra0 în loc de
eth0. Rulați __iwconfig__ fără nici un parametru, pentru a determina
numele corect al dispozitivului.

Pentru majoritatea utilizatorilor, sunt numai două setări importante
de schimbat, ESSID (adică numele rețelei wireless) și/sau cheia
WEP. Dacă ESSID și adresa Access Point listate sunt deja ca cele ale
Access Point-ului la care vă conectați și dacă nu folosiți WEP, atunci
rețeaua wireless este funcțională. Dacă aveți nevoie să schimbați
ESSID-ul sau să specificați o cheie WEP, puteți folosi următoarele
comenzi:

[source,bash]
.Schimbarea ESSID și/sau adăugarea cheii WEP
----
(Aceasta setează numele rețelei wireless la ”GentooNode”)
# iwconfig eth0 essid GentooNode
(Aceasta setează cheia WEP în notație hexa)
# iwconfig eth0 key 1234123412341234abcd
(Acesta setează cheia WEP, ASCII - o prefixăm cu ”s:”)
# iwconfig eth0 key s:some-password
----

Puteți acum să revedeți
setările pentru placa wireless folosind __iwconfig__. Odată ce aveți placa
wireless funcțională, puteți continua cu Configurarea adresei IP așa
cum este descrisă în următoarea secțiune (Terminologia utilizată în
rețelistică) sau să folosiți utilitarul __net-setup__ descris anterior.

Terminologia utilizată în rețelistică

NOTE: Dacă știți adresele dumneavoastră IP, broadcast, netmask și
serverele de nume, atunci puteți sări peste această subsecțiune și
puteți continua cu Folosirea ifconfig și route.

Dacă toate încercările de mai sus au eșuat, va trebui să vă
configurați rețeaua manual. Acest lucru nu este deloc dificil. În
schimb, trebuie să vă familiarizați cu câteva noțiuni de rețelistică
necesare configurării rețelei conform cerințelor dvs. Când veți
termina de citit această parte, veți ști ce este un gateway, la ce
folosește netmask, cum este formată adresa broadcast și de ce aveți
nevoie de servere de nume.

Într-o rețea, stațiile sunt identificate prin adresa IP (Internet
Protocol address). O astfel de adresă este o combinație de patru
numere între 0 și 255. Ei bine, cel puțin așa o percepem noi. În
realitate, o adresă IP constă în 32 biți (unu și zero). Să vedem un
exemplu:

Exemplu de adresă IP
....
Adresa IP (numeric): 192.168.0.2
Adresa IP (binar)  : 11000000  10101000  00000000  00000010
--------  --------  --------  --------
192       168       0         2
....

O adresă IP identifică în mod unic o stație din punctul de vedere al
subrețelelor accesibile (spre ex. fiecare stație care este accesibilă
trebuie să dețină o adresă IP unică). Pentru a putea distinge stațiile
din interiorul rețelei față de cele din exterior, adresa IP este
compusă din două părți: partea network și partea host.

Separarea este efectuată folosind netmask, o colecție de unu urmată de
o colecție de zero.  Partea din IP care se mapează pe unu este partea
network, cealaltă parte este partea host. În mod uzual, netmask (masca
rețelei) se poate scrie ca o adresă IP.

Exemplu de depanare network/host
....
Adresa IP: 192 168 0 2
11000000 10101000 00000000 00000010
Netmask:   11111111 11111111 11111111 00000000
+--------------------------+--------+
255      255      255      0
Network            Host
....

Cu alte cuvinte, 192.168.0.14 este încă, în exemplu nostru, în
rețea, dar 192.168.1.2 nu.  Adresa broadcast este adresa IP cu aceeași
parte network ca și rețeaua noastră, dar cu partea host formată numai
din unu. Fiecare stație din rețea ascultă pe această adresă IP. și
este folosită pentru transmisii de pachete broadcast.

Adresa Broadcast
....
Adresa IP: 192 168 0 2
11000000 10101000 00000000 00000010
11000000 10101000 00000000 11111111
Broadcast: 192      168      0        255
+--------------------------+--------+
Network            Host
....

Pentru a putea naviga pe internet, trebuie să cunoașteți care stație
partajează conexiunea la Internet. Această stație se numește
gateway. Cum aceasta este o stație obișnuită are și ea o adresă IP
obișnuită (de exemplu 192.168.0.1).

Anterior am stabilit că fiecare stație are propria
adresă IP. Pentru a putea recunoaște stațiile se asociază un nume (cum
ar fi dev.gentoo.org) unei adrese IP (cum ar fi 64.5.62.82). Un astfel
de serviciu este numit serviciu de nume. Pentru a folosi un astfel de
serviciu, trebuie să definiți serverele de nume în __/etc/resolv.conf__.

În unele cazuri, stația gateway este de asemenea și server de
nume. Dacă nu, va trebui să introduceți adresele serverelor de nume
furnizate de ISP-ul dumneavoastră.

Sintetizând, veți avea nevoie de următoarele informații pentru a
continua:

[width="50%",cols=2,options="header"]
|===
|Element rețea |Exemplu

|Adresa IP |192.168.0.2

|Netmask |255.255.255.0

|Broadcast |192.168.0.255

|Gateway |192.168.0.1

|Server(e) de nume |195.130.130.5
195.130.130.133
|===

Folosirea ifconfig și route

Setarea unei rețele constă în trei pași. Întâi ne o
să atribuim o adresă IP folosind __ifconfig__. Apoi vom seta ruta către
gateway folosind route. Apoi vom finaliza punând adresele IP
corespunzătoare serverelor de nume în __/etc/resolv.conf__.

Pentru a atribui o adresă IP, va trebui să cunoașteți adresele IP,
broadcast și netmask.  Apoi executați următoarea comandă, înlocuind
${IP_ADDR} cu adresa IP, ${BROADCAST} cu adresa broadcast și
${NETMASK} cu netmask-ul corespunzător:

[source,bash]
.Folosirea ifconfig
----
# ifconfig eth0 ${IP_ADDR} broadcast ${BROADCAST} netmask ${NETMASK} up
----

Acum setați ruta implicită folosind route. Înlocuiți ${GATEWAY} cu
adresa IP a gateway-ului:

[source,bash]
.Folosirea route
----
# route add default gw ${GATEWAY}
----

Acum deschideți
__/etc/resolv.conf__ cu editorul favorit (în exemplu nostru, o să folosim
__nano__):

[source,bash]
.Crearea /etc/resolv.conf
----
# nano -w /etc/resolv.conf
----

Acum completați cu adresele serverelor de nume folosind următoarea
machetă. Asigurați- vă că înlocuiți ${NAMESERVER1} și ${NAMESERVER2}
cu adresele IP corespunzătoare:

[source,bash]
.machetă /etc/resolv.conf
----
nameserver ${NAMESERVER1}
nameserver ${NAMESERVER2}
----

Acum testați rețeaua folosind ping către câteva servere din Internet
(ca de exemplu Google).  Funcționează? Felicitări atunci. Sunteți gata
să instalați Gentoo. Continuați cu Pregătirea Discurilor.


== Capitolul 4

=== Pregătirea discurilor

==== Introducere în dispozitive bloc

===== Dispozitive bloc

O să aruncăm o privire atentă asupra aspectelor în legătură cu
discurile din Gentoo Linux, în general, incluzând sistemele de
fișiere, partiții și dispozitive bloc. Apoi, odată ce vă familiarizați
cu toate aspectele despre discuri și sisteme de fișiere, veți fi
ghidați prin procesul de setare al partițiilor și sistemelor de
fișiere pentru instalarea dumneavoastră de Gentoo Linux.

Pentru a începe, o să facem introducerea dispozitivelor bloc. Cel mai
renumit dispozitiv bloc este probabil cel care reprezintă primul disc
dur (hard disk) într-un sistem Linux, și anume '/dev/sda'. Dacă
sistemul dumneavoastră. utilizează discuri SCSI sau SATA, atunci
primul dumneavoastră disc dur (hard disk) ar trebui să fie /dev/sd*;
chiar și discurile dure IDE sunt detectate ca /dev/sd* cu kernelurile
recente.

Dispozitivele bloc amintite mai sus, reprezintă o interfață abstractă
pentru disc. Programele utilizator pot folosi aceste dispozitive bloc
pentru a interacționa cu discul dumneavoastră fără a avea grija dacă
discurile dure sunt IDE, SATA, SCSI sau altceva. Programul poate
adresa ceea ce urmează să se stocheze pe disc ca o mulțime continuă de
blocuri de 512 octeți accesibile aleator.

*Partiții*

Deși este teoretic posibil să utilizăm un disc întreg pentru a găzdui
sistemul dvs. Linux, acesta este un lucru foarte rar pus în
practică. Mai degrabă, dispozitivele bloc întregi sunt împărțite în
dispozitive bloc mai mici și mai ușor de manipulat. Pe sistemele
AMD64, acestea sunt numite partiții.

Partițiile sunt împărțite în trei tipuri: primare, extinse și logice.

O partiție primară este o partiție ce deține informația stocată în
zona MBR (master boot record). Cum o zonă MBR este foarte mică (512
octeți) doar patru partiții primare pot fi definite (spre exemplu,
/dev/sda1 până la /dev/sda4).  O partiție extinsă este o partiție
primară specială (ceea ce înseamnă că partiția extinsă poate fi una
din cele patru partiții primare posibile) ce conține mai multe
partiții. O asemenea partiție nu a existat la începuturi, dar, cum
cele patru partiții erau prea puține, a fost inventată pentru a
extinde schema de formatare fără să se piardă compatibilitatea cu cea
anterioară.

O partiție logică este o partiție conținută într-o partiție extinsă.
Definirea acestora nu se face în MBR, ci în interiorul partiției
extinse.

*Stocare avansată*

Mediile Installation CD pentru arhitectura AMD64 oferă suport pentru
LVM2. LVM2 mărește flexibilitatea oferită de setarea partițiilor. Pe
parcursul instrucțiunilor de instalare, o să ne concentrăm pe partiții
”obișnuite”, dar este, totuși, bine să știți că este suportat și LVM2.

==== Proiectarea unei scheme de partiționare

*Schema de partiționare implicită*

Dacă nu sunteți interesat în proiectarea unei scheme de partiționare
pentru sistemul dumneavoastră, puteți utiliza schema de partiționare
pe care o folosim pe tot parcursul manualului:


[width="80%",cols="3,^4,^4,10",options="header"]
|===
|Partiție |Sistem de Fișiere |Mărime |Descriere

|'/dev/sda1' |ext3 sau ext4 |100M |Partiția pentru boot

|'/dev/sda2' |(swap) |1024M |Partiția pentru swap

|'/dev/hda3' |ext4 |Restul discului |Partiția pentru rădăcină
|===

Dacă vă interesează cât de mare ar trebui să fie o partiție, sau chiar
de câte partiții aveți nevoie, citiți mai departe.  Altfel, continuați
cu Utilizarea *fdisk* sau *parted* pentru partiționarea discului
(amândouă sunt utilitare pentru partiționare, fdisk este un utilitar
stabil, parted este mai recent dar suporta partiții mai mari de 2TB).

*Cât de multe și cât de mari?*

Numărul de partiții este în foarte mare măsură dependent de mediul
dumneavoastră. Spre exemplu, dacă aveți un număr foarte mare de
utilizatori, cel mai probabil veți dori să aveți directorul /home
separat, deoarece sporește securitatea și facilitează operațiile de
backup. Dacă instalați Gentoo ca server de mail, directorul
dumneavoastră /var ar trebui să fie separat, pentru că toate
mail-urile sunt stocate în /var. O bună alegere a sistemului de
fișiere va mări la maxim performanțele. Serverele de jocuri vor avea o
partiție /opt separată, deoarece majoritatea aplicațiilor server
pentru jocuri sunt instalate acolo. Motivul este similar cu cel pentru
/home: securitate și backup. Veți dori în mod sigur să vă păstrați
directorul /usr mai mare: nu numai că va conține majoritatea
aplicațiilor, dar numai structura Portage ocupă în jur de 500 MOcteți,
excluzând sursele ce sunt stocate în acesta.

După cum puteți observa, depinde foarte mult de scopul pe care doriți
să-l atingeți. Partițiile sau volumele separate au următoarele
avantaje:

- Puteți alege cel mai performant sistem de fișiere pentru fiecare
partiție sau volum;

- Întregul sistem nu poate rămâne fără spațiu liber dacă o aplicație
nefuncțională scrie în continuu fișiere pe o partiție sau volum;

- Dacă este necesar, verificările sistemului de fișiere sunt reduse ca
timp, deoarece se pot executa mai multe verificări în paralel (deși
acest avantaj este mai mare în cazul discurilor multiple, decât în
cel al partițiilor multiple);

- Securitatea poate fi îmbunătățită prin montarea unor partiții sau
volume doar pentru citire, în mod nosuid (biții setuid sunt
ignorați), noexec (biții pentru execuție sunt ignorați), etc.

În orice caz, partițiile multiple au un mare dezavantaj. Dacă nu sunt
configurate corect, pot cauza ca un sistem să aibă foarte mult loc
liber pe o partiție și fără loc liber pe alta. Un alt inconvenient
este că partițiile separate (în special pentru punctele de montare
importante, cum ar fi /usr sau /var) necesită adesea ca
administratorul să încarce (boot-eze) cu un initramfs pentru a monta
partiția înainte de a începe scripturile de inițializare să
pornească. Nu este întotdeauna cazul, deci rezultatul poate
varia. Deși există o limitare la 15 partiții pentru SCSI și SATA
puteți folosi GPT.

Ca un exemplu de partiționare, o să vă arătam unul pentru un disc de
20GO, utilizat pe un laptop demonstrativ (conține aplicații server
pentru web, aplicații server pentru mail, gnome, ...):

[source,bash]
.Exemplu de utilizarea sistemului de fișiere
----
$ df -h
Filesystem    Type    Size     Used    Avail    Use%              Mounted on
/dev/sda5     ext4    509M     132M    351M     28%                    /
/dev/sda2     ext4    5.0G     3.0G    1.8G     63%                 /home
/dev/sda7     ext4    7.9G     6.2G    1.3G     83%                  /usr
/dev/sda8     ext4    1011M    483M    477M     51%                  /opt
/dev/sda9     ext4    2.0G     607M    1.3G     32%                  /var
/dev/sda1     ext4    102M     40M      60M     40%                 /boot
/dev/sda6     swap    1032M    24M     1008M     2%             <not mounted>
----
(Spațiu nepartiționat pentru utilizarea ulterioară: 2 GOcteți)

'/usr' este destul de plin (83% utilizat), dar odată ce toate
aplicațiile software sunt instalate '/usr' nu va tinde să mai crească
prea mult. Deși alocarea unor câțiva giga-octeți de spațiu de disc
pentru '/var' ar putea părea excesiv, amintiți-vă că Portage
utilizează această partiție implicit pentru compilarea
pachetelor. Dacă doriți să vă păstrați '/var' la o mărime mai
rezonabilă, cum ar fi 1 GO, va trebui să modificați variabila
dvs. PORTAGE_TMPDIR din '/etc/make.conf' să indice către partiția cu
spațiu liber suficient pentru compilarea pachetelor extrem de mari,
cum ar fi OpenOffice/Libreoffice.

==== Utilizarea fdisk pentru a vă partiționa discul

Următoarele părți explică modul de creare a exemplului de schemă
de partiționare descris anterior, adică:


[width="40%",cols="2",options="header"]
|===

| Partiție   | Descriere

| '/dev/sda1'  | Partiția pentru boot

| '/dev/sda2'  | Partiția pentru swap

| '/dev/sda3'  | Partiția pentru rădăcină
|===


Schimbați schema de de partiționare în concordanță cu propriile
preferințe.

*Vizualizarea schemei de partiționare curentă*

*fdisk* este un utilitar foarte popular și puternic pentru a vă împărți
discul în partiții.  Porniți *fdisk* pentru discul dumneavoastră (în
exemplul nostru, utilizăm '/dev/sda'):


[source,bash]
.Lansarea fdisk
----
# fdisk /dev/sda
----

Odată ce intrăm în fdisk, veți fi întâmpinați cu un prompt ce va arăta
așa:

....
Promptul fdisk
Command (m for help):
....

Tastați *p* pentru a afișa configurația curentă a partițiilor discului
dvs.:

(Un exemplu de configurație de partiții)
....
Command (m for help): p

Disk /dev/sda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes

Device Boot    Start    End      Blocks     Id    System
/dev/sda1        1       14     105808+     83    Linux
/dev/sda2       15       49      264600     82    Linux swap
/dev/sda3       50       70      158760     83    Linux
/dev/sda4       71      2184    15981840    5     Extended
/dev/sda5       71      209     1050808+    83    Linux
/dev/sda6       210     348     1050808+    83    Linux
/dev/sda7       349     626     2101648+    83    Linux
/dev/sda8       627     904     2101648+    83    Linux
/dev/sda9       905     2184    9676768+    83    Linux
Command (m for help):
....


Acest disc este configurat să găzduiască șapte sisteme de fișiere
Linux (fiecare cu o partiție corespondentă afișată ca "Linux") precum
și o partiție swap (afișată ca "Linux swap").

*Ștergerea tuturor partițiilor*

Mai întâi o să ștergem toate partițiile existente pe disc.  Tastați *d*
pentru a șterge o partiție. Spre exemplu, pentru a șterge o partiție
existentă '/dev/sda1':

....
Ștergerea unei partiții

Command (m for help): d
Partition number (1-4): 1
....

Partiția a fost programată pentru ștergere. Nu va mai fi afișată dacă
tastați *p*, dar nu va fi ștearsă până când schimbările nu vor fi
salvate. Dacă ați efectuat o greșeală și doriți să anulați fără să
salvați schimbările, tastați *q* imediat și apoi *enter* și partițiile
dumneavoastră nu vor fi șterse.

Acum, presupunând că doriți într-adevăr să ștergeți toate partițiile
de pe sistemul dumneavoastră, tastați în mod repetat *p* pentru a vi
se afișa tabela de partiții și apoi tastați *d* și numărul partiției
pe care doriți să o ștergeți. În cele din urmă, veți termina având o
tabelă de partiție ce nu va conține nimic:

....
O tabelă de partiții goală

Disk /dev/sda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes = 7741440 bytes

Device Boot    Start    End    Blocks    Id    System

Command (m for help):
....

Acum că tabela de partiții din memorie este goală, suntem gata de a
crea partițiile. O să utilizam o schemă de partiționare implicită, așa
cum am amintit anterior. Bineînțeles, nu urmați aceste instrucțiuni
mot-a-mot dacă nu doriți aceeași schemă de partiționare.

*Crearea partiției pentru boot*

Mai întâi trebuie creată o partiție pentru boot (încărcare sistem)
mică. Tastați n pentru a crea o nouă partiție, apoi p pentru a o
selecta ca partiție primară, urmat de 1 pentru a selecta prima
partiție primară. Când vi se va cere primul cilindru, apăsați
enter. Când vi se va cere ultimul cilindru, tastați +32M pentru a crea
o partiție de 32 MOcteți ca mărime:

....
Crearea partiției pentru boot

Command (m for help): n
Command action
e extended
p primary partition (1-4)
p
Partition number (1-4): 1
First cylinder (1-3876, default 1): (Apăsați Enter)
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default  3876): +32M
....

Acum, când tastați *p*, ar trebui să vi se afișeze:

....
Partiția de boot creată

Command (m for help): p

Disk /dev/sda: 240 heads, 63 sectors, 2184 cylinders
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes = 7741440 bytes

Device Boot    Start    End    Blocks     Id    System
/dev/sda1      1        14     105808+    83    Linux
....


Trebuie să facem această partiție capabilă de a încărca sistemul
(boot). Tastați a pentru a activa indicatorul de boot pentru această
partiție și apoi selectați *1*. Dacă apăsați *p* din nou, veți observa
că un caracter * este afișat pe coloana "Boot".

*Crearea partiției pentru swap*

Acum, trebuie creată partiția pentru swap. Pentru acest lucru, tastați
*n* pentru o nouă partiție, apoi *p* pentru a-i specifica aplicației
fdisk că doriți o partiție primară. Apoi, tastați *2* pentru a o crea
ca a doua partiție primară, '/dev/sda2' în cazul nostru. Când vi se va
cere primul cilindru, apăsați enter. Când vi se va cere ultimul
cilindru, tastați +512M pentru a crea o partiție de mărimea a 512
MO. După ce ați specificat acest lucru, apăsați *t* pentru a seta
tipul partiției, *2* pentru a selecta partiția pe care tocmai ați
creat-o, și apoi tastați 82 pentru a seta tipul partiției ca "Linux
Swap". După terminarea acestor pași, prin tastarea *p* ar trebui să se
afișeze o tabelă de partiții similară cu aceasta:

....
Afișarea partițiilor după crearea partiției pentru swap

Command (m for help): p

Disk /dev/sda: 240 heads, 63 sectors, 2184 cylinders
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes = 7741440 bytes

Device Boot    Start    End    Blocks     Id    System
/dev/sda1      1        14     105808+    83    Linux
/dev/sda2      15       81     506520     82    Linux swap
....

*Crearea partiției rădăcină*

În cele din urmă, trebuie creată partiția rădăcină. Pentru acest
lucru, tastați *n* pentru a crea o nouă partiție, apoi p pentru a îi
specifica aplicației *fdisk* că doriți o partiție primară. Apoi
tastați *3* pentru a o crea ca a treia partiție primară, '/dev/sda3'
în cazul nostru. Când vi se va cere primul cilindru, apăsați
*enter*. Când vi se va cere ultimul cilindru, apăsați *enter* pentru a
crea o partiție ce va ocupa restul spațiului rămas disponibil pe
discul dumneavoastră. După terminarea acestor pași, prin tastarea *p*
ar trebui să se afișeze de tabelă de partiții similară cu aceasta:

....
Afișarea partițiilor după crearea partiției rădăcină

Command (m for help): p

Disk /dev/sda: 240 heads, 63 sectors, 2184 cylinders
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes = 7741440 bytes

Device Boot    Start    End     Blocks      Id    System
/dev/sda1      1        14      105808+     83    Linux
/dev/sda2      15       81      506520      82    Linux swap
/dev/sda3      82       3876    28690200    83    Linux
....

*Salvarea schemei de partiționare*

Pentru a salva schema de partiționare și a ieși din fdisk, tastați *w*.

....
Salvarea și ieșirea din fdisk

Command (m for help): w
....

Acum că partițiile dumneavoastră sunt create, puteți continua cu
Crearea Sistemelor de Fișiere.

==== Crearea sistemelor de fișiere

*Introducere*

Acum, că partițiile dumneavoastră sunt create, este timpul să aplicăm
un sistem de fișiere pe acestea. Dacă nu vă pasă ce sistem de fișiere
utilizați și sunteți mulțumiți cu ceea ce utilizăm noi implicit în
acest manual, continuați cu Aplicarea unui sistem de fișiere pe o
partiție. Altfel, citiți mai departe pentru a învăța despre sistemele
de fișiere disponibile.

*Sisteme de fișiere*

Kernel-ul Linux suportă diverse sisteme de fișiere. O să vă explicăm
ext2, ext3, ext4, ReiserFS, XFS și JFS, deoarece sunt sistemele de
fișiere utilizate cel mai des pe sistemele Linux.

[horizontal]

*ext2*:: este cel mai încercat sistem de fișiere Linux, dar nu conține
destule informații de tip metadata pentru jurnalizare, ceea ce
înseamnă că verificările de rutină ale sistemului de fișiere
ext2 la pornirea sistemului pot dura o perioada considerabilă
de timp. Există acum o mulțime de sisteme de fișiere
jurnalizate din noua generație ce pot fi verificate pentru
consistență foarte repede și de aceea sunt preferate în locul
celor nejurnalizate. Sistemele de fișiere jurnalizate previn
durata lungă la pornirea sistemului când sistemul de fișiere
este într-o stare de inconsitență.

*ext3*:: este versiunea jurnalizată a sistemului de fișiere ext2,
oferind informații de jurnalizare de tip metadata în plus față
de ext2, îmbunătățire ca jurnalizarea completă a datelor și
jurnalizarea ordonată a datelor pentru recuperări rapide. ext3
este un sistem de fișiere foarte bun și sigur. Conține o
indexare adițională b-tree, opțiune de indexare ce oferă o
performanță bună în aproape toate situațiile. Puteți activa
această indexare prin adăugarea opțiunii -O dir_index comenzii
mke2fs.

*ext4*:: este un tip de fișier de sistem creat ca un branșament al
tipului ext3 aducând noi opțiuni, îmbunătățiri ale performanței
și reducând limitele de dimensiuni cu schimbări moderate la
formatul pe disc. Poate deschide volume de până la 1 EB cu o
dimensiune maximă a partiției de 16 TB. Spre deosebire de
clasicul ext2/3 în alocarea blocului bitmap, ext4 folosește
extents, care îmbunătățește performața fișierelor de dimensiuni
mari și reduce fragmentarea. Ext4 folosește de asemenea o
metodă mai sofisticată de algoritmi pentru alocarea
block-urilor (alocare întârziată și alocare multiblock) dând
dispozitivului de sistem mai multe opțiuni de optimizare a
configurării datelor pe disc. Tipul ext4 este un compromis
între nivelele de producție, stabilitatea codului și dorința de
a introduce extensii unui tip de sistem de fișiere vechi de
aproape o decadă. Ext4 este genul de tip de fișier de sistem
”pentru orice scop” și ”pentru orice platformă”.

*ReiserFS*:: este un sistem de fișiere B*-tree ce oferă în general o
performanță foarte bună și depășește mult atât ext2 cât și
ext3 în cazul fișierelor mici (mai mici de 4K), în cele mai
multe cazuri cu un coeficient de 10-15 ori. ReiserFS oferă
o scalabilitate foarte bună și conține jurnalizare de tip
metadata. ReiserFS este solid și utilizabil atât în cazuri
normale cât și pentru cazuri extreme cum ar fi crearea de
sisteme de fișiere foarte mari, utilizarea multor fișiere
foarte mici, fișiere foarte mari și directoare conținând
zeci de mii de fișiere.

*XFS*:: este un sistem de fișiere cu jurnalizare metadata ce are un set
de funcționalități robuste și este optimizat pentru
scalabilitate. Recomandăm utilizarea acestui sistem de fișiere
doar pe sistemele Linux ce conțin discuri SCSI și/sau sisteme de
stocare pe fibra optică și care dețin o sursă de alimentare
neîntreruptibilă. Deoarece XFS utilizează într-un mod agresiv
păstrarea datelor tranzitate în RAM, programele ce nu sunt
proiectate corect (cele care nu își asigură precauții la
scrierea fișierelor pe disc care sunt destul de puține) pot
pierde multe date dacă sistemul se oprește în mod neașteptat.

*JFS*:: este sistemul de fișiere cu jurnalizare de înaltă performanță al
IBM. A devenit gata pentru producție și nu există prea multe
înregistrări pentru a comenta pozitiv sau negativ asupra
stabilității generale a acestuia în acest moment.

*Aplicarea unui sistem de fișiere pe o partiție*

Pentru a crea un sistem de fișiere pe o partiție sau volum, există
utilitare disponibile pentru fiecare sistem de fișiere existent:

[width="45%",cols="2",options="header"]
|===
| Sistem de fișiere | Comanda pentru creare

| ext2 | mkfs.ext2

| ext3 | mkfs.ext3

| ext4 | mkfs.ext4

| reiserfs | mkreiserfs

| xfs | mkfs.xfs

| jfs | mkfs.jfs
|===

Spre exemplu, pentru a avea partiția de boot ('/dev/sda1' în exemplul
nostru) ca ext2 și partiția rădăcină ('/dev/sda3' în exemplul nostru)
ca ext4 (ca în exemplul nostru), ar trebui să utilizați:

[source,bash]
.Aplicarea unui sistem de fișiere pe o partiție
----
# mkfs.ext2       /dev/sda1
# mkfs.ext4       /dev/sda3
----

Acum creați sistemele de fișiere pe partițiile (sau volumele
logice) nou create.

*Activarea partiției swap*

*mkswap* este comanda utilizată pentru a inițializa partițiile swap:

[source,bash]
.Crearea unei semnături swap
----
# mkswap /dev/sda2
----

Pentru a activa partiția swap, utilizați *swapon*:

[source,bash]
.Activarea partiției swap
----
# swapon /dev/sda2
----

Creați și activați partiția swap utilizând comenzile menționate
anterior.

==== Montarea

Acum ca partițiile dumneavoastră sunt inițializate și găzduiesc un
sistem de fișiere, este timpul să montați (n.t.: mount în lb.
engleză) aceste partiții.

Utilizați comanda *mount*. Nu uitați să creați directoarele de montare
pentru fiecare partiție creată. Ca un exemplu, o să montăm partițiile
rădăcină și de boot:

[source,bash]
.Montarea partițiilor
----
# mount /dev/sda3 /mnt/gentoo
# mkdir /mnt/gentoo/boot
# mount /dev/sda1 /mnt/gentoo/boot
----

NOTE: Dacă doriți ca directorul '/tmp' să se afle pe o partiție
separată, asigurați-vă că îi schimbați permisiunile după
montare: chmod 1777 /mnt/gentoo/tmp. Aceasta este valabil și
pentru '/var/tmp'.

Trebuie, de asemenea, să utilizăm mount pentru sistemul de fișiere
*proc* (o interfață virtuală cu kernel-ul) în '/proc'. Dar, mai întâi
va trebui să stocăm fișierele noastre pe partiții.

Continuați cu Instalarea fișierelor Gentoo necesare instalării.

== Capitolul 5

=== Instalarea fișierelor Gentoo necesare instalării

==== Instalarea unei arhive tar stage

Înainte de a continua, trebuie să verificați data/ora și să o
actualizați. Un ceas configurat greșit ar putea duce la rezultate
ciudate pe viitor.

Pentru a verifica data/ora curentă, executați date.

[source,bash]
.Verificarea datei/orei
----
# date
Fri Mar 29 16:21:18 UTC 2005
----

Dacă data/ora sunt afișate greșit, actualizați-le folosind sintaxa
date MMDDhhmmYYYY (Month - Lună, Day - Zi, hour - Oră, minute - Minut
și Year - An). La acest pas, trebuie să utilizați zona de fus orar
UTC. Veți putea să vă definiți zona de fus orar, ulterior. De exemplu,
pentru a seta data de 29 Martie, 16:21, a anului 2005:

[source,bash]
.Setarea datei/orei UTC
----
# date 032916212005
----

*Alegerea dumneavoastră*

Următorul pas pe care trebuie să îl urmați este să instalați arhiva
tar stage3 pe sistemul dumneavoastră. Comanda *uname -m* poate fi
utilizată pentru a vă ajuta să decideți ce arhivă tar stage să
descărcați.

==== Implicit: Folosirea unui stage de pe internet

*Descărcarea arhivei stage*

Mergeți în directorul în care ați montat sistemul de fișiere Gentoo
(cel mai probabil în '/mnt/gentoo'):

[source,bash]
.Intrăm în directorul în care am montat Gentoo
----
# cd /mnt/gentoo
----

În funcție de mediul de instalare, aveți câteva unelte disponibile
pentru a descărca un stage. Dacă aveți links disponibil, atunci puteți
naviga cu ușurință către lista de servere mirror Gentoo și să alegeți
unul cât mai apropiat de dumneavoastră. Tastați links
http://www.gentoo.org/main/en/mirrors.xml și apăsați ENTER.

Dacă nu aveți disponibilă aplicația links, ar trebui să aveți
aplicația lynx la dispoziție. Dacă trebuie să utilizați un server
proxy, exportați variabilele http_proxy și ftp_proxy:

[source,bash]
.Setarea informațiilor despre proxy pentru lynx
----
# export http_proxy="http://proxy.server.com:port"
# export ftp_proxy="http://proxy.server.com:port"
----

O să presupunem, de acum, că aveți la dispoziție links.

Selectați un mirror apropiat. De obicei un mirror HTTP este de ajuns,
dar puteți alege și alte protocoale.

Selectați directorul releases/, urmat de cel al arhitecturii folosite
(de exemplu amd64/autobuilds/). Acolo ar trebui să găsiți toate
arhivele tar stage disponibile pentru arhitectura dumneavoastră (este
posibil să fie stocate în directoare având numele subarhitecturilor
individuale). Selectați una și apăsați D pentru a o descărca. Când ați
terminat, apăsați Q pentru a ieși din browser.

[source,bash]
.Navigarea cu links a listelor de mirror-uri
----
# links http://www.gentoo.org/main/en/mirrors.xml
(Dacă aveți nevoie de suport pentru proxy cu links:)
# links -http-proxy proxy.server.com:8080
http://www.gentoo.org/main/en/mirrors.xml
----

Asigurați-vă că ați descărcat o arhivă tar stage3 - instalările
utilizând un fișier stage1 sau stage2 nu mai sunt suportate.

Dacă doriți să verificați integritatea arhivei descărcate, folosiți
openssl și comparați ceea ce este afișat cu suma aflată pe
mirror. Fișierul digest vă furnizează câteva sume de control, fiecare
având un algoritm propriu. Cele recomandate sunt SHA512 și
Whirlpool. Spre exemplu, pentru a verifica integritatea arhivei tar
stage pentru amd64:

[source,bash]
.Verificarea integrității arhivei
----
# openssl dgst -r -sha512 stage3-amd64-<release>.tar.bz2
sau
# sha512sum stage3-amd64-<release>.tar.bz2
## Calculating the Whirlpool checksum
# openssl dgst -r -whirlpool stage3-amd64-<release>.tar.bz2
----

Apoi comparați ceea ce au returnat comenzile de mai sus cu valorile
din fișierul .DIGESTS pe care îl găsiți pe mirror.  Valorile trebuie
să coincidă, altfel fișierul descărcat ar putea fi corupt.

*Despachetarea arhivei*

Acum despachetați arhiva descărcată pe sistemul dumneavoastră.  Noi
utilizăm tar pentru această operație, fiind cea mai simplă metodă:

[source,bash]
.Despachetarea arhivei stage
----
# tar xvjpf stage3-*.tar.bz2
----

Asigurați-vă că folosiți aceleași opțiuni (xvjpf). Opțiunea x înseamnă
Extract, v vine de la Verbose pentru a observa ceea ce se întâmplă în
timpul procesului de extracție (această opțiune este facultativă), j
vine de la Decompress with bz2, p înseamnă Preserve permissions , iar
f denotă că vrem să dezarhivăm un fișier și nu datele de la intrarea
standard (en: standard input).

Acum că avem stage-ul instalat, continuăm cu Instalarea Portage.

==== Configurarea opțiunilor de compilare

*Introducere*

Pentru optimizarea Gentoo, puteți seta unele variabile ce vor
determina comportamentul Portage. Toate aceste variabile pot fi setate
ca variabile de mediu (folosind export), dar acest lucru nu este
permanent. Pentru a vă menține setările, Portage conține un fișier de
configurare /etc/portage/make.conf. Acest fișier îl o să îl editam
acum.

NOTE: O listă comentată a tuturor variabilelor, poate fi găsită în
'/mnt/gentoo/usr/share/portage/make.conf.example'. Pentru o
instalare reușită Gentoo va trebui doar să setați aceste
variabile menționate mai sus.

Deschideți editorul de text favorit (în acest ghid noi folosim nano)
astfel încât să modificăm variabilele de optimizare, pe care le vom
explica în continuare.

[source,bash]
.Deschiderea /etc/portage/make.conf
----
# nano -w /mnt/gentoo/etc/portage/make.conf
----

Așa cum probabil ați observat, fișierul make.conf.example este
structurat într-un mod generic: liniile comentate încep cu "#", iar
celelalte definesc variabile folosind sintaxa:
VARIABLE="conținut". Fișierul make.conf utilizează aceeași
sintaxă. Multe dintre acele variabile sunt discutate în continuare.

*CFLAGS și CXXFLAGS*

Variabilele CFLAGS și CXXFLAGS definesc opțiunile de optimizare pentru
compilatorul gcc de C respectiv C++. Deși, în general, le definim
aici, veți obține maximul de performanță dacă optimizați flag-urile
pentru fiecare program în parte. Motivul pentru această afirmație este
că fiecare program este diferit.

În make.conf ar trebui să definiți opțiunile de optimizare care
credeți că vor face sistemul cât mai rapid în general. Nu puneți
valori experimentale în acest fișier; o optimizare prea mare poate
duce la un comportament ciudat al programelor (oprirea funcționării,
sau chiar mai rău, funcționarea incorectă).

Nu o să explicam toate opțiunile de optimizare. Dacă vreți să le
aflați pe toate, citiți Manualul(ele) Online GNU sau gcc pagina info
(info gcc -- funcționează doar pe un sistem Linux
funcțional). Fișierul make.conf.example conține, de asemenea, multe
exemple și informații; nu uitați să-l citiți.

O primă opțiune este indicatorul -march= sau -mtune=, care specifică
numele arhitecturii țintă. Opțiunile posibile sunt descrise în
fișierul make.conf.example (sub formă de comentarii).  De obicei se
folosește valoarea native care spune compilatorului să selecteze
arhitectura sistemului țintă (cel pe care se face instalarea).

Al doilea este indicatorul -O (care reprezintă majuscula O, nu cifra
zero), care specifică clasa de optimizare gcc. Clasele posibile sunt s
(pentru optimizarea mărimii), 0 (zero - pentru nici o optimizare), 1,
2 sau 3 pentru mai multe optimizări de viteză (fiecare clasă are
aceiași indicatori ca cea dinainte, plus altele). -O2 este recomandat
ca implicit. -O3 poate produce instabilitate, de aceea este recomandat
-O2.

O altă setare comună de optimizare este -pipe (utilizează canale pipe
în locul fișierelor temporare pentru comunicația între diversele etape
ale compilării). Ea nu are impact asupra codului generat, dar
folosește mai multă memorie. Pe sisteme cu memorie puțină este
recomandat a nu se folosi acest parametru.

Luați aminte faptul că utilizarea -fomit-frame-pointer (ce nu
păstrează indicatorul frame într-un registru pentru funcțiile ce nu
necesită acest lucru) poate avea repercursiuni serioase asupra
aplicațiilor de depanare!

Când definiți CFLAGS și CXXFLAGS, ar trebui să combinați mai multe
opțiuni de optimizare.

Valorile inițiale ce fac referire la CFLAGS si CXXFLAGS, conținute de
arhiva stage3 pe care ați despachetat-o ar trebui să fie de
ajuns. Iată un exemplu ce conține astfel de variabile.

[source,bash]
.Definirea variabilelor CFLAGS și CXXFLAGS
----
CFLAGS="-march=k8 -O2 -pipe" # Intel EM64T users should use -march=core2
# Use the same settings for both variables
CXXFLAGS="${CFLAGS}"
----

NOTE: Pentru mai multe informații cu privire la diferite variabile
pentru optimizare vizitați
http://www.gentoo.org/doc/en/gcc-optimization.xml?style=printable[Compilation
Optimization Guide] .

*MAKEOPTS*

Cu ajutorul MAKEOPTS definiți câte compilări paralele vor apărea când
instalați un pachet. O alegere bună este numărul procesoarelor din
sistem plus încă unul, dar această sugestie nu este întotdeauna
perfectă.

Fiți gata, Pregătiți-vă, Porniți!

Actualizați fișierul '/mnt/gentoo/etc/portage/make.conf', cu
preferințele dumneavoastră și salvați (utilizatorii nano tastează
Ctrl-X). Acum sunteți gata să continuați cu Instalarea Sistemului de
Bază al Gentoo.

== Capitolul 6

=== Instalarea sistemului de bază al Gentoo

==== Utilizarea mediului chroot

*Opțional: Alegerea mirror-urilor*

Pentru a descărca sursele mai rapid, este recomandat să selectați un
server mirror rapid. Portage va căuta în fișierul dumneavoastră
make.conf definiția variabilei GENTOO_MIRRORS și va utiliza server-ele
mirror afișate acolo. Puteți naviga în documentul nostru ce conține
http://www.gentoo.org/main/en/mirrors.xml?style=printable[lista cu
servere mirror] și căuta un server mirror (sau mai multe) mai
apropiate de dumneavoastră (deoarece, în cele mai multe cazuri,
acestea sunt și cele mai rapide), sau puteți utiliza utilitarul
mirrorselect oferit de noi, cu care puteți printr-o interfață
prietenoasă, să selectați server-ele mirror pe care le doriți.

[source,bash]
.Utilizarea mirrorselect pentru variabila GENTOO_MIRRORS
----
# mirrorselect -i -o >> /mnt/gentoo/etc/portage/make.conf
----

O altă setare importantă este variabila SYNC din make.conf.  Această
variabilă conține server-ul rsync pe care doriți să-l utilizați când
vă actualizați structura Portage (colecția de fișiere ebuild,
script-urile ce conțin toate informațiile de care Portage are nevoie
pentru a descărca și a instala aplicațiile).  Deși puteți introduce
manual un server SYNC, mirrorselect vă poate ușura această operație:

[source,bash]
.Selectarea unui server mirror rsync utilizând mirrorselect
----
# mirrorselect -i -r -o >> /mnt/gentoo/etc/portage/make.conf
----

După rularea mirrorselect este recomandat să verificați încă o dată
setările din /mnt/gentoo/etc/portage/make.conf!

NOTE: Dacă doriți să setați un server de SYNC manual în make.conf, ar
trebui să încercați lista cu servere mirror și să alegeți un
mirror cât mai apropiat de dumneavoastră ca și locație. Noi vă
recomandam să alegeți o listă de mirror-uri pe care sa o salvați
în make.conf și nu doar un mirror. Deoarece în cazul în care un
mirror este indisponibil să se utilizeze următorul mirror ce se
află în fișierul make.conf.

*Precizarea Informațiilor despre DNS*

A rămas un singur lucru de făcut, înainte să putem intra în noul
mediu, și anume trebuie să copiem informațiile despre DNS în
/etc/resolv.conf. Trebuie să facem asta, pentru a fi siguri că rețeaua
funcționează, chiar și după ce intrăm în noul mediu.  /etc/resolv.conf
conține serverele DNS pentru rețeaua noastră.

[source,bash]
.Copierea informațiilor despre DNS
----
# cp -L /etc/resolv.conf /mnt/gentoo/etc/resolv.conf
----

(Opțiunea "-L" ne asigură că nu copiem un link simbolic)

*Montarea sistemelor de fișiere*

În câteva momente o să schimbăm root-ul Linuxului către noua
locație. Ca să ne asigurăm că noul mediu este funcțional trebuie să
facem câteva sisteme de fișiere disponibile.

Montați sistemul de fișiere /proc în '/mnt/gentoo/proc' pentru a
permite procesului de instalare să utilizeze informația oferită de
kernel, chiar și în mediul chroot, și apoi montați prin legătură
sistemele de fișiere '/dev' și '/sys'.


[source,bash]
.Montarea sistemului de fișiere
----
# mount -t proc none /mnt/gentoo/proc
# mount --rbind /sys /mnt/gentoo/sys
# mount --rbind /dev /mnt/gentoo/dev
----

*Intrarea în noul mediu*

Acum, că toate partițiile sunt inițializate și mediul de bază este
instalat, a venit momentul să intrăm în noul mediu prin acțiunea de
chrooting în acesta. Aceasta înseamnă că ne mutăm din mediul în care a
decurs instalarea (Installation CD sau alt mediu de instalare), în
sistemul instalat (adică în partiția inițializată).

Acțiunea de chrooting, se face în trei etape. Mai întâi, vom muta
rădăcina, din '/' (de pe discul de instalare), către '/mnt/gentoo' (de
pe partiția aleasa pentru instalare), folosind comanda chroot. Apoi,
variabilele distribuite de /etc/profile le încărcăm în memorie,
folosind comanda source. Iar în ultimul pas redefinim promptul pentru
a ne ajuta să ne reamintim că suntem într-un mediu chrootat (mediul
unde se realizează instalarea).

[source,bash]
.Chroot în noul mediu
----
# chroot /mnt/gentoo /bin/bash
# source /etc/profile
# export PS1="(chroot) $PS1"
----

Felicitări! Sunteți acum în propriul mediu Gentoo Linux. Desigur,
suntem departe de a fi terminat, motiv pentru care procesul de
instalare mai are câteva secțiuni de parcurs.

Dacă vreodată aveți nevoie de un alt terminal sau consolă ca să
accesați un mediu chrootat, tot ceea ce trebuie să faceți este să
executați pașii de mai sus.

==== Configurarea Portage

*Despachetarea structurii Portage*

Acum trebuie să instalați structura Portage, o colecție de fișiere ce
informează portage ce software poți instala, ce profile sunt
disponibile etc. Conținutul structurii Portage va fi extras în
'/usr/portage'.

Noi vă recomandăm să folosiți emerge-webrsync. Acesta vă va descărca
ultima structură Portage (pe care Gentoo o pune la dispoziție zilnic)
de pe un mirror (oglindă) al comunității, ca apoi să vi-l instaleze în
sistem.

[source,bash]
.Rularea lui emerge--webrsync pentru a instala o structură Portage
----
# mkdir /usr/portage
# emerge-webrsync
----

*Opțional: Actualizarea structurii Portage*

Acum, trebuie să vă actualizați structura Portage la ultima
versiune. emerge --sync efectuează această acțiune pentru
dumneavoastră. El va folosi protocolul rsync pentru a face update (a
aduce ultima versiune, a actualiza) structurii Portage pe care ați
descărcat-o mai devreme folosind emerge-webrsync.

[source,bash]
.Actualizarea structurii Portage
----
# emerge --sync

(Dacă utilizați un terminal lent, cum ar fi unele terminale
framebuffer sau console seriale, puteți adăuga opțiunea --quiet
pentru a mări viteza acestui proces:)
# emerge --sync --quiet
----

Dacă vă aflați în spatele unui firewall ce blochează traficul rsync,
puteți ignora această etapă din moment ce aveți deja o structură
Portage actualizată.

Dacă sunteți atenționat că o noua versiune Portage este disponibilă ar
fi bine să actualizați Portage, aceasta se face cu ajutorul comenzii
emerge --oneshot Portage. De asemenea veți fi notificați despre
noutățile/știrile ce trebuie citite (news items need reading).

*Citirea știrilor*

Când structura Portage este sincronizata/actualizată, Portage vă poate
atenționa/avertiza cu următorul mesaj:

....
Portage vă va informa că noi stiri sunt disponibile

* IMPORTANT: 2 news items need reading for repository 'gentoo'.
* Use eselect news to read news items.
....

Știrile venite prin Portage sunt create pentru a înlesni comunicarea
cu utilizatorii cărora le sunt trimise mesaje importante prin
protocolul rsync. Pentru a le administra trebuie sa folosiți eselect
news. Cu sub-comanda read veți putea citi toate articolele. Cu list
veți putea vedea toate articolele cu știri disponibile, iar cu purge
puteți șterge articolele cu știri citite de care nu mai aveți nevoie.

[source,bash]
.Manipularea articolelor din Portage
----
# eselect news list
# eselect news read
----

Mai multe informații despre cititorul de știri sunt disponibile prin
accesarea informațiilor din manualul comenzii: man news.eselect.

*Alegerea profilului corect*

Mai înainte de toate, o mică definiție.

Un profil este un bloc ce stă la baza construirii oricărui sistem
Gentoo. Nu numai că specifică valorile implicite pentru CHOST, CFLAGS
și alte variabile importante, dar și blochează sistemul într-o anumită
plajă de versiuni ale pachetelor. Mentenanța tuturor acestora este
asigurată de dezvoltatorii Gentoo.

Anterior, un asemenea profil era neatins de către utilizator. În orice
caz, sunt situații când poți decide dacă o modificare de profil este
necesară.

Puteți vedea ce profil utilizați în mod curent, prin execuția
următoarei comenzi:

[source,bash]
.Verificarea profilului de sistem
----
# eselect profile list
Available profile symlink targets:
[1] default/linux/amd64/13.0 *
[2] default/linux/amd64/13.0/desktop
[3] default/linux/amd64/13.0/server
----

După cum puteți vedea, sunt disponibile atât subprofile desktop cât și
server pentru câteva arhitecturi.

Rularea lui eselect profile list ne va afișa toate profilele
disponibile.

După ce ați văzut profilele disponibile pentru arhitectura
dumneavoastră, puteți folosi unul dintre cele listate dacă doriți.

[source,bash]
.Schimbarea profilelor
----
# eselect profile set 2
----

Dacă doriți un sistem pe 64 de biți pur, fără biblioteci sau aplicații
pe 32 de biți, ar trebui sa folosiți profilul non-multilib:

[source,bash]
.Schimbarea profilului pe non-multilib
----
# eselect profile list
Available profile symlink targets:
[1] default/linux/amd64/13.0 *
[2] default/linux/amd64/13.0/desktop
[3] default/linux/amd64/13.0/no-multilib
[4] default/linux/amd64/13.0/server
(Choose the no-multilib profile)
# eselect profile set 3
(Verify the change)
# eselect profile list
Available profile symlink targets:
[1] default/linux/amd64/13.0
[2] default/linux/amd64/13.0/desktop
[3] default/linux/amd64/13.0/no-multilib *
[4] default/linux/amd64/13.0/server
----

NOTE: Profilul developer este specific dezvoltării de task-uri în
Gentoo Linux. Acesta nu este conceput să ajute setarea unui
mediu de dezvoltare general.

*Configurarea variabilei USE*

USE este una dintre cele mai puternice variabile, pe care Gentoo o
pune la dispoziția utilizatorilor. Multe dintre programe pot fi
compilate, cu sau fără suport opțional pentru diferite pachete.  De
exemplu, unele programe pot fi compilate cu suport GTK sau cu suport
QT. Altele pot fi compilate cu sau fără suport SSL. Unele programe pot
fi chiar compilate cu suport framebuffer (svgalib), în loc de suport
X11 (X-server).

Majoritatea distribuțiilor își compilează propriile pachete, folosind
suport pentru cât mai multe lucruri posibile, crescând astfel
dimensiunea programelor și totodată a timpului de pornire, fără a
menționa enorma cantitate de dependențe. Folosind Gentoo, puteți
defini cu ce opțiuni să fie compilat un pachet. Aici intră în joc,
variabila USE.

În cadrul variabilei USE, definiți cuvinte cheie care sunt folosite în
opțiunile compilării. De exemplu, opțiunea ssl va compila suportul
pentru ssl, în cadrul programelor care îl suportă. -X va elimina
suportul pentru X-server (observați semnul minus din față). gnome gtk
-kde -qt va compila programele cu suport gnome (gtk) dar fără suport
kde (și qt), făcându-vă sistemul, pe deplin optimizat pentru GNOME.

Setările USE implicite se află în fișierele make.defaults din profilul
dumneavoastră. Veți putea regăsi fișierele make.defaults în directorul
spre care indică /etc/portage/make.profile și în toate directoarele
ascendente. Setarea USE reprezintă suma tuturor setărilor USE din
toate fișierele make.defaults. Ceea ce adăugați în
/etc/portage/make.conf este calculat în concordanță cu aceste setări
implicite. Dacă adăugați ceva setărilor USE, este adăugat listei
implicite. Dacă ștergeți ceva din setările USE (prin scrierea semnului
minus în fața sa), atunci este șters din lista implicită (în cazul în
care ar fi fost în listă).  Niciodată nu faceți schimbări în
interiorul directorului /etc/portage/make.profile; va fi rescris când
actualizați Portage!

O descriere completă a variabilelor USE existente, poate fi găsită în
'/usr/portage/profiles/use.desc'.

[source,bash]
.Vizualizarea indicatorilor USE existenți
----
# less /usr/portage/profiles/use.desc
----

(Puteți derula utilizând tastele săgeți și să ieșiți prin apăsarea 'q')

Drept exemplu, vă prezentăm setările unui sistem bazat pe KDE, cu
suport DVD, ALSA și CD-Recording:

[source,bash]
.Deschidem /etc/portage/make.conf
----
# nano -w /etc/portage/make.conf
----

[source,bash]
.Setările USE
----
USE="-gtk -gnome qt4 kde dvd alsa cdr"
----

==== Localizarea

În cele din urmă selectați-vă localizarea pentru ca sistemul
dumneavoastră să știe unde sunteți localizat fizic. Pentru localizare
(timezone) uitați-vă în /usr/share/zoneinfo, apoi copiați în
/etc/localtime. Zonele de timp din /usr/share/zoneinfo/Etc/GMT* după
cum sugerează și denumirea, nu indică exact zonele așteptate. De
exemplu, GMT-8 este de fapt GMT+8.

[source,bash]
.Setarea localizării
----
# ls /usr/share/zoneinfo
(Suppose you want to use Europe/Bucharest)
# cp /usr/share/zoneinfo/Europe/Bucharest /etc/localtime
(Next set the timezone)
# echo "Europe/Brussels" > /etc/timezone
----

== Capitolul 7

=== Configurarea Kernel-ului

==== Instalarea surselor

*Alegerea unui kernel*

Nucleul în jurul căruia sunt construite toate distribuțiile, este
kernel-ul Linux. Este nivelul dintre programe și componentele hardware
ale sistemului dumneavoastră. Gentoo pune la dispoziția
utilizatorilor, mai multe surse de kernel. O listă completă alături de
descrierea lor, este accesibilă la
http://www.gentoo.org/doc/en/gentoo-kernel.xml?style=printable[Ghidul
Gentoo pentru Kernel] .

Pentru sistemele bazate pe arhitectura amd64 vă oferim, alături de
alte surse de kernel, vanilla-sources (sursele de kernel implicite
dezvoltate de programatorii de kernel Linux), gentoo-sources (sursele
de kernel ce conțin patch-uri pentru îmbunătățirea performanței).

Alegeți sursele de kernel și instalați-le utilizând emerge.

[source,bash]
.Instalarea unor surse de kernel
----
# emerge gentoo-sources
----

Când vă veți uita în /usr/src ar trebui să vedeți un symlink
numit linux, ce indică spre sursa kernel-ului dumneavoastră. În
acest caz, sursele kernel-ului instalate indică către
gentoo-sources-3.4.9. Versiunea dumneavoastră ar putea fi
diferită, deci rețineți acest aspect.

[source,bash]
.Vizualizare symlink sursă kernel
----
# ls -l /usr/src/linux
lrwxrwxrwx 1 root root 12 Oct 13 11:04 /usr/src/linux -> linux-3.4.9
----

Acum este timpul să configurăm și să compilăm sursa kernel. Toate
arhitecturile pot folosi genkernel pentru asta, care va construi un
kernel generic așa cum este folosit pe mediul Installation CD.  O să
explică configurarea manuală, acesta fiind totuși cea mai bună cale de
a vă optimiza sistemul.

Dacă doriți să vă configurați kernel-ul manual, continuați acum cu
Implicit:
http://www.gentoo.org/doc/en/handbook/handbook-amd64.xml?style=printable&full=1#manual[Configurarea
Manuală] .

Dacă doriți să utilizați genkernel, ar trebui să citiți Alternativ:
http://www.gentoo.org/doc/en/handbook/handbook-amd64.xml?style=printable&full=1#genkernel[Utilizarea
genkernel] .

==== Implicit: Configurarea manuală

*Introducere*

Configurarea manuală a kernel-ului este des percepută ca cea mai grea
încercare, pe care fiecare utilizator Linux trebuie să o treacă. Nimic
mai fals, după ce veți configura câteva kernel-uri, nici nu vă veți
mai aminti că a fost greu.

Totuși, un lucru este adevărat: trebuie să vă cunoașteți sistemul
înainte de a începe configurarea manuală a kernel-ului. Cele mai multe
informații le puteți obține prin instalarea pciutils (emerge pciutils)
care conține utilitarul lspci. Acum veți putea să utilizați comanda
lspci în interiorul mediului chroot. Puteți ignora cu încredere orice
avertismente pcilib (cum ar fi: pcilib: cannot open
/sys/bus/pci/devices) afișate de lspci. Alternativ, puteți rula lspci
dintr-un mediu non-chroot. Rezultatele sunt aceleași. De asemenea,
puteți rula lsmod pentru a vizualiza modulele kernel-ului folosit de
mediul Installation CD (ar putea să vă formeze o idee despre ce anume
să activați).

Acum mergeți în directorul ce conține sursa kernel-ului și executați
make menuconfig. Aceasta va porni un meniu de configurare bazat pe
ncurses.

[source,bash]
.Invocarea menuconfig
----
# cd /usr/src/linux
# make menuconfig
----

Veți fi întâmpinat cu mai multe secțiuni de configurare. Mai întâi o
să enumerăm câteva opțiuni pe care trebuie să le activați (altfel
Gentoo nu va funcționa deloc sau nu va funcționa corect fără anumite
trucuri suplimentare).

*Activarea opțiunilor necesare*

Asigurați-vă că fiecare driver ce este vital pentru procesul de
încărcare (boot) al sistemului dumneavoastră (cum ar fi controller-ul
SCSI, ...) este compilat în kernel, și nu ca modul, altfel sistemul
dumneavoastră nu va putea completa procesul de încărcare (boot).

O să alegem apoi tipul exact al procesorului. Pentru tipul de
instalare amd64 recomandăm utilizatorilor să activeze funcția MCE,
astfel încât să poată fi notificați în cazul unor probleme
hardware. Pe arhitectura amd64, aceste erori nu sunt listate de dmesg
așa cum sunt listate pe alte arhitecturi, dar sunt listate în
/dev/mcelog. Acesta necesită pachetul app-admin/mcelog.  Asigurați-vă
că aveți selectat IA32 Emulation dacă doriți să rulați și aplicații pe
32 de biți. Această opțiune este necesară deoarece Gentoo vă
instalează un sistem multilib (computație mixtă pe 32 de biți si 64 de
biți).

NOTE: Dacă aveți în plan să utilizați profilul non-multilib (pentru un
sistem 64 biți), atunci nu selectați suportul IA32
Emulation. Totuși va trebui să urmați următoarele instrucțiuni
pentru a vă comuta sistemul pe profilul non-multilib, precum și
alegerea corectă a încărcătorului de sistem (bootloader).

....
Selectarea procesorului după tip și caracteristici

Processor type and features --->
[ ] Machine Check / overheating reporting
[ ] Intel MCE Features
[ ] AMD MCE Features
Processor family (AMD-Opteron/Athlon64) --->
( ) Opteron/Athlon64/Hammer/K8
( ) Intel P4 / older Netburst based Xeon
( ) Core 2/newer Xeon
( ) Intel Atom
( ) Generic-x86-64
Executable file formats / Emulations --->
[*] IA32 Emulation
....

La pasul următor selectați fișierele de sistem maintain și devtmpfs să
fie montate pe locația /dev pentru ca fișierele de dispozitiv critice
să fie disponibile în modul de boot inițial.

....
Activare suport devtmpfs

Device Drivers --->
Generic Driver Options --->
[*] Maintain a devtmpfs filesystem to mount at /dev
[ ] Automount devtmpfs at /dev, after the kernel mounted the rootfs
....

Acum duceți-vă la File Systems și selectați sistemul de fișiere
folosit. Nu compilați sistemul de fișiere folosit pentru partiția root
ca modul, altfel sistemul nu va putea să vă monteze partiția. De
asemenea selectați memoria virtuala și /proc.

....
Selectarea sistemului de fișiere necesar

File systems --->
(Select one or more of the following options as needed by your
stem)  |
<*> Second extended fs support
<*> Ext3 journalling file system support
<*> The Extended 4 (ext4) filesystem
<*> Reiserfs support
<*> JFS filesystem support
<*> XFS filesystem support
...
Pseudo Filesystems --->
[*] /proc file system support
[*] Virtual memory file system support (former shm fs)

(Enable GPT partition label support if you used that previously)
-*- Enable the block layer --->
...
Partition Types --->
[*] Advanced partition selection
...
[*] EFI GUID Partition support
....

Dacă folosiți PPPoE ca să va conectați la internet sau folosiți un
modem dial-up, va trebui să activați următoarele opțiuni în kernel.

....
Selectarea driverelor necesare pentru PPPoE

Device Drivers --->
Network device support --->
<*> PPP (point-to-point protocol) support
<*> PPP support for async serial ports
<*> PPP support for sync tty ports
....

Cele două forme de compresie sunt bune dar nu sunt neapărat necesare,
la fel cum și opțiunea PPP peste Ethernet, care poate fi folosită de
ppp când este configurat modul kernel PPPoE.

Dacă aveți nevoie de aceasta, nu uitați să includeți și suportul în
kernel pentru placa de rețea.

Dacă aveți un sistem multi-CPU Opteron sau unul multi-core (e.g.
AMD64 X2), va trebui să activați "Symmetric multi-processing support":

....
Activare suport SMP

Processor type and features --->
[*] Symmetric multi-processing support
....

NOTE: În sistemele multi-core fiecare nucleu este interpretat ca un
procesor.

Dacă folosiți dispozitive USB (precum tastatura sau/și mouse) nu
uitați să activați și aceste opțiuni:

....
Activare suport USB

Device Drivers --->
[*] HID Devices --->
<*> USB Human Interface Device (full HID) support
....

*Compilarea și Instalarea*

Acum, că kernel-ul este configurat, este timpul să îl compilați și
să-l instalați. Ieșiți din meniul de configurare și începeți procesul
de compilare:

[source,bash]
.Compilarea kernel-ului
----
# make && make modules_install
----

Când compilarea s-a terminat, copiați imaginea de kernel în directorul
/boot. Utilizați orice nume considerați că este potrivit pentru
kernel-ul dumneavoastră și amintiți-vă acest nume deoarece veți avea
nevoie de el ulterior când veți configura aplicația încărcătorul de
sistem (bootloader). Amintiți-vă să înlocuiți kernel-3.4.9-gentoo cu
numele și versiunea kernel-ului dumneavoastră.

[source,bash]
.Instalarea kernel-ului
----
# cp arch/x86_64/boot/bzImage /boot/kernel-3.4.9-gentoo
----

*(Opțional) Construirea initramfs*

Dacă folosiți o schemă de partiționare unde /usr și/sau /var sunt
partiții separate, atunci aveți nevoie să setați initramfs pentru ca
partițiile să fie montate înainte de a fi folosite.

Fară initramfs, riscați ca sistemul dumneavoastră să nu booteze
deoarece acest utilitar este responsabil cu montarea acestor
partiții. Acest utilitar initramfs pune fișierele necesare într-o
arhivă, arhivă ce este folosită imediat după ce kernelul este pornit
(bootează), dar înainte ca controlul să fie dirijat spre utilitarul de
inițializare.

Initramfs va avea grija ca partițiile sa fie montate înainte ca
sistemul să își continue bootarea.

Pentru a instala initramfs mai întâi aveți nevoie de genkernel, acesta
vă va genera un initramfs pentru dumneavoastră.

[source,bash]
.Generare initramfs
----
# emerge genkernel
# genkernel --install initramfs
----

Dacă aveți nevoie de suport specific în initramfs, ca LVM sau raid,
adăugați aceste opțiuni genkernel-ului. Pentru mai multe informații
genkernel --help, în următorul exemplu o să activăm suportul pentru
LVM și raid (mdadm):

[source,bash]
.Crearea lui initramfs cu suport LVM și raid
----
# genkernel --lvm --mdadm --install initramfs
----

Fișierul initramfs va fii stocat în directorul /boot. Veți găsi
fișierul cu un simplu listing ce conține cuvântul initramfs.

[source,bash]
.Listarea fisierului initramfs
----
# ls /boot/initramfs*
----

Acum, continuați cu
http://www.gentoo.org/doc/en/handbook/handbook-amd64.xml?style=printable&full=1#kernel_modules[Module
de Kernel] .

==== Alternativ: Utilizarea genkernel

Dacă citiți această secțiune, înseamnă că ați ales script-ul nostru
genkernel pentru a vă configura kernel-ul.

Acum că sursele kernel-ului sunt instalate, este timpul să compilăm
kernel-ul folosind scriptul genkernel, pentru o compilarea automată a
kernel-ului. genkernel funcționează prin a configura un kernel aproape
identic cu cel al mediului Installation CD. Asta înseamnă că atunci
când folosiți genkernel pentru a vă construi un kernel, sistemul va
detecta, la modul general, toate componentele hardware, în timpul
procesului de încărcare (boot), așa cum o face mediul Installation
CD. Deoarece genkernel nu necesită vreo configurare manuală a
kernel-ului, este ideal pentru cei cărora nu le este la îndemână să-și
compileze propriile kernel-uri. Acum să vedem cum se folosește
genkernel. Mai întâi, instalați pachetul genkernel:

[source,bash]
.Instalarea genkernel
----
# emerge genkernel
----

Acum, compilați sursa kernel-ului rulând genkernel all. Fiți atenți,
totuși, că genkernel compilează un kernel care suportă aproape toate
componentele hardware, compilarea durând ceva timp pentru a se
termina.

Trebuie să știți că dacă partiția de boot nu folosește ext2 sau ext3
ca sistem de fișiere, va trebui să configurați manual kernel-ul,
folosind genkernel --menuconfig all și să adăugați suport pentru
sistemul respectiv de fișiere în kernel (nu ca modul). Utilizatorii de
LVM2 vor trebui probabil să adauge --lvm2 ca argumente.

[source,bash]
.Rularea genkernel
----
# genkernel all
----

Odată ce genkernel își încheie execuția, vor fi create un set întreg
de module și initramfs.

O să folosim kernel-ul și initrd când o să configurăm încărcătorul de
sistem (bootloader-ul). Notați undeva numele imaginii de kernel și al
fișierului initrd pentru că vă va trebui când veți configura aplicația
încărcătorul de sistem (bootloader). Initrd-ul va porni imediat după
boot, pentru a iniția autodetecția hardware (la fel ca și la mediul
Installation CD) înainte ca "adevăratul" sistem să pornească.

[source,bash]
.Verificarea numelor imaginii de kernel creată și a initrd-ului
----
# ls /boot/kernel* /boot/initramfs*
----

==== Module de Kernel

*Configurarea Modulelor*

Va trebui să enumerați toate modulele, pe care vreți să le încărcați
automat, în /etc/conf.d/modules. Puteți, de asemenea, să adaugați
extra opțiuni modulelor dacă doriți.

Pentru a vizualiza toate modulele disponibile, folosiți următoarea
comandă find. Nu uitați să înlocuiți "<versiune kernel>" cu versiunea
efectivă de kernel pe care tocmai ați compilat-o:

[source,bash]
.Vizualizarea tuturor modulelor disponibile
----
# find /lib/modules/<kernel version>/ -type f -iname '*.o' -or -iname '*.ko'  less
----

De exemplu, pentru încărcarea automata a modulului 3c59x.ko (un driver
pentru plăcile de rețea 3Com), editați fișierul /etc/conf.d/modules și
scrieți numele modulului în el.

[source,bash]
.Inserare module in /etc/conf.d/modules
----
# nano -w /etc/conf.d/modules
modules_3_4="3c59x"
----

(unde 3_4 este versiunea majora a kernelului instalat)

Continuați instalarea cu
http://www.gentoo.org/doc/en/handbook/handbook-amd64.xml?style=printable&full=1#book_part1_chap8[Configurarea
Sistemului].

== Capitolul 8

=== Configurarea Sistemului

==== Informații despre sistemul de fișiere

*Ce este fstab?*

Sub Linux, toate partițiile folosite de sistem trebuie scrise în
/etc/fstab. Fișierul conține punctele de montare a partițiilor (unde
apar în structura sistemului de fișiere), cum trebuie montate și cu ce
opțiuni speciale pot fi montate (montare automată sau nu, dacă
utilizatorii normali (non-root) pot monta sau nu partiția, etc.).

*Crearea /etc/fstab*

'/etc/fstab' folosește o sintaxă specială. Fiecare linie conține șase
câmpuri, separate de spațiu/spații, taburi, sau o combinație între
cele două. Fiecare câmp își are propria semnificație:

- Primul câmp prezintă partiția respectivă (calea către fișierul
dispozitiv).

- Al doilea câmp arată directorul de montare, unde partiția
trebuie să fie montată.

- Al treilea câmp arată sistemul de fișiere folosit pe partiție.

- Al patrulea câmp arată opțiunile folosite la montarea
partițiilor. Deoarece fiecare sistem de fișiere are opțiuni de
montare specifice, sunteți încurajați să citiți manualul comenzii
mount (man mount) pentru o listare completă. Punctele de montare
sunt separate prin virgulă.

- Al cincilea câmp este folosit de dump pentru a determina dacă pentru
partiția respectivă trebuie efectuat dump sau nu. În general, se
poate lăsa valoarea standard 0 (zero).

- Al șaselea câmp este utilizat de fsck pentru a determina ordinea în
care sistemele de fișiere trebuie verificate, în cazul în care PC-ul
nu a fost oprit în mod normal. Sistemul de fișiere root ar trebui să
aibă valoarea 1, în timp ce restul partițiilor ar trebui să aibă 2
(sau 0, dacă verificarea nu este necesară).

Atenție: Fișierul /etc/fstab implicit prezent în Gentoo nu este un
fișier valid, așadar, porniți nano (sau editorul favorit) pentru a
crea /etc/fstab:

[source,bash]
.Deschiderea /etc/fstab
----
# nano -w /etc/fstab
----

Să vedem cum scriem opțiunile pentru partiția /boot. Acesta este doar
un exemplu, astfel, dacă arhitectura folosită nu necesită /boot (cum
sunt mașinile PPC de la Apple), nu o copiați.

În exemplul nostru implicită pentru AMD64, /boot este partiția
/dev/sda1, cu ext2 ca sistem de fișiere. Trebuie verificat în timpul
procesului de încărcare (boot), așadar o să scriem:

....
Un exemplu de linie /boot pentru /etc/fstab

/dev/sda1        /boot        ext2        defaults        0 2
....

Unii utilizatori nu doresc ca partiția lor '/boot' să fie montată
automat, pentru a îmbunătăți securitatea sistemului. Aceștia trebuie
să înlocuiască defaults cu noauto. Aceasta înseamnă că trebuie să
montați manual partiția de câte ori doriți să o folosiți.

Adăugați regulile corespunzătoare schemei de partiționare și atașați
regulile pentru dispozitivele CD-ROM și adăugați de asemenea orice
alte partiții și dispozitive aferente.

Acum folosiți exemplul de mai jos pentru a vă crea fișierul
'/etc/fstab':

....
Un exemplu de fișier /etc/fstab complet

/dev/sda1      /boot      ext2      defaults,noatime      0 2
/dev/sda2      none      swap     sw      0 0
/dev/sda3      /      ext4      noatime      0 1
/dev/cdrom      /mnt/cdrom      auto      noauto,user      0 0
....

Pentru a îmbunătăți performanța, cei mai mulți utilizatori ar trebui
să adauge opțiunea noatime, opțiune ce va duce la o mărire a vitezei
sistemului, fiindcă timpii de acces nu sunt înregistrați (în general
nu sunt necesari).

Opțiunea auto face ca mount să ghicească ce sistem de fișiere
(recomandat pentru componente detașabile) să folosească, iar opțiunea
user oferă posibilitatea ca utilizatorii obișnuiți să poată monta
unitatea optică (CD/DVD-ROM).

Verificați de două ori fișierul /etc/fstab, apoi salvați și ieșiți
înainte de a continua.

==== Informații rețea

*Hostname, Domainname etc.*

O decizie ce trebuie făcută de utilizator este numele PC-ului.
Aceasta pare a fi ușoară, dar mulți utilizatori au dificultăți în a
alege un nume potrivit pentru PC-ul cu Linux. Pentru a grăbi puțin
lucrurile, trebuie să știți că orice nume alegeți, acesta poate fi
modificat ulterior. Puteți pur și simplu să vă numiți sistemul tux și
domeniul homenetwork.

[source,bash]
.Setarea numelui
----
# nano -w /etc/conf.d/hostname
hostname="tux"
----

(Setați variabila HOSTNAME pentru numele sistemului)

A doua decizie este legată de domainname, dacă aveți nevoie de
domaninname setați-l prin editarea fișierului /etc/conf.d/net.  Aveți
nevoie de domeniu doar dacă ISP-ul sau administratorul dumneavoastră
de rețea o cere, sau dacă aveți un server DNS dar nu și unul de
DHCP. Dacă folosiți DHCP nu aveți de ce să vă îngrijorați cu privire
la domainnames sau DNS.

[source,bash]
.Setarea numelui domeniului
----
# nano -w /etc/conf.d/net
dns_domain_lo="homenetwork"
----

(Setați variabila DNSDOMAIN cu numele domeniului dvs.)

Dacă aveți un domeniu NIS (dacă nu știți ce este acesta, sigur nu
utilizați așa ceva), aveți nevoie să-l definiți și pe acesta:

[source,bash]
.Setarea numelui de domeniu NIS
----
# nano -w /etc/conf.d/net
nis_domain_lo="my-nisdomain"
----

(Setați variabila DNSDOMAIN cu numele domeniului dvs.)

NOTE: Dacă doriți mai multe informații despre DNS și NIS vă rugam să
      citiți exemplele aflate în
      /usr/share/doc/openrc-*/net.example.bz2 ce pot fi citite
      folosind bzless. De asemenea poate doriți să vă instalați
      openresolv (emerge openresolv) pentru a vă ajuta la
      administrarea DNS/NIS.

*Configurarea rețelei*

Înainte de a avea acea stare "Hei, am mai făcut asta o dată", trebuie
să știți că setările făcute la începutul instalării au fost doar
pentru instalare. Acum, vom face configurările permanente pentru noul
sistem Gentoo.

NOTE: Informații mai detaliate despre rețea, incluzând subiecte
      avansate ca sistemele bonding, bridging, rețele VLAN 802.1Q sau
      rețelistica wireless, sunt incluse în secțiunea despre [
      http://www.gentoo.org/doc/en/handbook/handbook-amd64.xml?style=printable&full=1#book_part4[Configurarea
      Rețelei] în Gentoo.

Toate setările rețelei sunt ținute în '/etc/conf.d/net'. Acesta
folosește o sintaxă simplă, dar care nu poate fi folosită intuitiv,
dacă nu știți să setați rețeaua manual. Dar nu vă temeți, o să vă
explicăm totul. Un exemplu de fișier comentat ce acoperă diverse
configurații este disponibil în
'/usr/share/doc/openrc-*/net.example.bz2'.

DHCP este utilizat implicit. Pentru a utiliza DHCP trebuie să
instalați un client DHCP. Aceasta este descrisa în
http://www.gentoo.org/doc/en/handbook/handbook-amd64.xml?style=printable&full=1#networking-tools[Instalarea
utilitarelor necesare de sistem ]. Nu uitați să instalați un client
pentru DHCP.

Dacă trebuie să vă configurați conexiunea la rețea, fie pentru că
aveți nevoie să specificați anumite opțiuni DHCP sau pentru că nu
utilizați deloc DHCP, deschideți '/etc/conf.d/net' cu editorul favorit
(în acest exemplu este folosit nano):

[source,bash]
.Deschiderea /etc/conf.d/net pentru editare
----
# nano -w /etc/conf.d/net
----

Veți observa următorul fișier:

....
Fișierul implicit /etc/conf.d/net

# This blank configuration will automatically use DHCP for any t.*
# scripts in /etc/init.d. To create a more complete configuration,
# please review /usr/share/doc/openrc-*/net.example.bz2 and save your
# configuration in /etc/conf.d/net (this file :]!).
....

Pentru a introduce propriile dumneavoastră. adrese IP, netmask și
gateway, trebuie să setați atât config_eth0 cât și routes_eth0:

NOTE: Asta presupune ca interfața rețelei dumneavoastră să fie
      eth0. În orice caz asta depinde de sistem. Dacă imaginea de pe
      care instalați sistemul este suficient de recentă când porniți
      sistemul (boot) presupunem că interfața de rețea are același
      nume ca și înainte de boot.

....
Setarea manuală a informațiilor despre IP pentru eth0

config_eth0="192.168.0.2 netmask 255.255.255.0 brd 192.168.0.255"
routes_eth0="default via 192.168.0.1"
....

Pentru a utiliza DHCP, definiți config_eth0:

....
Obținerea unei adrese IP pentru eth0 în mod automat

config_eth0="dhcp"
....

Vă rugăm să consultați fișierul
'/usr/share/doc/openrc-*/net.example.bz2' pentru o listă cu toate
opțiunile disponibile. Dacă vreți setări specifice citiți manualele
clientului dumneavoastră DHCP.

Dacă aveți mai multe interfețe de rețea atunci repetați pașii de mai
sus pentru config_eth1, config_eth2 etc.

Salvați configurația și ieșiți pentru a continua.

*Pornirea Automată a Rețelei la Boot*

Pentru a activa interfețele de rețea la boot, acestea trebuie adăugate
la nivelul de execuție default.

[source,bash]
.Adăugarea net.eth0 la nivelul de execuție default
----
# cd /etc/init.d
# ln -s net.lo net.eth0
# rc-update add net.eth0 default
----

Dacă aveți mai multe interfețe de rețea, trebuie să creați scripturi
apropiate de genul net.*, exact cum ați făcut cu net.eth0.

Dacă mai târziu găsiți că numele interfețelor de rețea sunt
greșite (pe care momentan le-am numit eth0 ... ), atunci:

1. modificați fișierul '/etc/conf.d/net' cu numele interfeței corecte
(ca enp3s0 în loc de eth0),

2. creați noi link-uri simbolice (ca /etc/init.d/net.enp3s0),

3. ștergeți vechile link-uri simbolice (rm /etc/init.d/net.eth0),

4. adăugați-le pe cele noi în nivelul de execuție inițial, și

5. ștergeți-le pe cele vechi utilizând rc-update del net.eth0
default.

*Scrierea informațiilor despre rețea*

Trebuie să informați linux-ul despre rețea. Acesta este definită în
'/etc/hosts' și permite rezolvarea numelor corespondente adreselor IP
pentru host-urile ce nu sunt rezolvate de serverul DNS. Trebuie să vă
definiți sistemul. De asemenea, ați putea să definiți și alte sisteme
din rețeaua dumneavoastră dacă nu doriți să vă setați propriul server
intern de DNS.

[source,bash]
.Deschiderea /etc/hosts
----
# nano -w /etc/hosts
----

....
Completarea cu informații privind rețeaua

(Aceasta definește sistemul curent)

127.0.0.1 tux.homenetwork tux localhost

(Definiți alte sisteme din rețeaua locală. Acestea au nevoie de o
resă IP statică pentru a fi definite în acest mod.)

192.168.0.5 jenny.homenetwork jenny
192.168.0.6 benny.homenetwork benny
....

Salvați și ieșiți din editor pentru a continua.

Dacă nu aveți PCMCIA, puteți continua cu
http://www.gentoo.org/doc/en/handbook/handbook-amd64.xml?style=printable&full=1#sysinfo[Informațiile
despre Sistem ] . Utilizatorii PCMCIA ar trebui să citească următoarea
parte despre PCMCIA.

*Opțional: Activarea PCMCIA în scopul funcționării*

Utilizatorii PCMCIA ar trebui să instaleze mai întâi pachetul
pcmciautils.

[source,bash]
.Instalarea pcmciautils
----
# emerge pcmciautils
----

==== Informații Despre Sistem

*Parola pentru Root*

Mai întâi setăm parola pentru root, tastând:

[source,bash]
.Setarea parolei pentru root
----
# passwd
----

*Informații despre sistem*

Gentoo folosește '/etc/rc.conf' pentru configurații generale, care
afectează tot sistemul. Deschideți '/etc/rc.conf' și savurați toate
comentariile din acest fișier.

[source,bash]
.Deschiderea /etc/rc.conf
----
# nano -w /etc/rc.conf
----

Când ați terminat configurarea în fișierul /etc/rc.conf, salvați și
ieșiți.

După cum se poate observa, fișierul are multe comentarii pentru a vă
ajuta cu setarea corectă a variabilelor de configurare necesare. Vă
puteți configura fonturile pentru consolă, editorul implicit și
managerul de login (ca gdm sau kdm).

Gentoo utilizează '/etc/conf.d/keymaps' pentru a manipula configurarea
tastaturii. Editați-l pentru a vă configura tastatura.

[source,bash]
.Deschiderea fișierului /etc/conf.d/keymaps
----
# nano -w /etc/conf.d/keymaps
----

Acordați mai multă atenție variabilei KEYMAP. Dacă selectați în mod
greșit KEYMAP, veți obține rezultate ciudate când tastați.

Când ați terminat configurarea '/etc/conf.d/keymaps', salvați și
ieșiți.

Gentoo utilizează '/etc/conf.d/hwclock' pentru a seta opțiunile de
ceas. Editați-l conform nevoilor dumneavoastră.

[source,bash]
.Deschiderea fișierului /etc/conf.d/hwclock
----
# nano -w /etc/conf.d/hwclock
----

Dacă ceasul hardware nu este setat la UTC, trebuie sa adăugați
CLOCK="local" în acest fișier. Altfel, veți observa mesaje despre
"clock skew" (ceas desincronizat). În plus, Windows presupune că
ceasul hardware este setat ca local, deci dacă doriți dualboot ar
trebui să setați această variabilă corespunzător, altfel vor apărea
probleme.

Când ați terminat configurarea '/etc/conf.d/hwclock', salvați și
ieșiți.

*Configurarea localizării*

Probabil pe sistemul dumneavoastră folosiți doar una sau două
localizări. Va trebui să specificați localizările dorite în
'/etc/locale.gen'.

[source,bash]
.Deschiderea fișierului /etc/locale.gen
----
# nano -w /etc/locale.gen
----

Următoarele localizări sunt specifice pentru limba engleză (Statele
Unite) și romană (Romania), localizări ce sunt acompaniate și de
suportul UTF-8.

....
Specificarea localizărilor

en_US ISO-8859-1
en_US.UTF-8 UTF-8
ro_RO ISO-8859-2
ro_RO.UTF-8 UTF-8
....

NOTE: Puteți să vă selectați localizările dorite dintr-o lista rulând
comanda locale -a.

ATENȚIE: Unele aplicații au nevoie de UTF-8 de aceea vă recomandam să
folosiți cel puțin o localizare cu suport UTF-8.

După rulați locale-gen. Acesta vă va genera toate localizările pe care
le-ați specificat în /etc/locale.gen.

[source,bash]
.Generarea localizărilor
----
# locale-gen
----

Imediat după ce ați setat localizarea aveți posibilitatea să setați
localizări la nivel de sistem în fișierul '/etc/env.d/02locale'.

....
Setarea localizării implicite în /etc/env.d/02locale

LANG="ro_RO.UTF-8"
LC_COLLATE="C"
....

și reîncărcați mediul:

[source,bash]
.Reîncărcarea shelului
----
# env-update && source /etc/profile
----

Pentru a vă ajuta cu localizarea am creat un
http://www.gentoo.org/doc/en/guide-localization.xml?style=printable#doc_chap3[ghid]
complet. Dacă aveți nevoie de informații specifice cu privire la
UTF-8 puteți de asemenea să citiți
http://www.gentoo.org/doc/en/utf-8.xml?style=printable#doc_chap2[Ghidul
UTF-8].

Vă rugam să continuați cu Instalarea Utilitarelor de Sistem Necesare.

== Capitolul 9

=== Instalarea utilitarelor de sistem necesare

==== Sistemul de log

Unele utilitare lipsesc din arhiva stage3 pentru că există mai multe
pachete care oferă aceeași funcționalitate. Depinde de dumneavoastră,
acum, să le alegeți pe cele pe care le doriți instalate.

Primul instrument pentru care trebuie să te decizi, trebuie să asigure
facilități de logare pentru sistemul tău. Unix și Linux au istorie
excelentă în acest domeniu. Dacă doriți puteți să logați tot ce se
întâmplă în sistemul dumneavoastră în fișierele log. Aceasta se
întâmplă prin system logger.

Gentoo oferă mai multe sisteme de logare dintre care puteți
alege. Printre altele se numără sysklogd, care este un set tradițional
de sisteme de logare, syslog-ng și metalog un sistem avansat de logare
care este cel mai configurabil. Alte sisteme de logare sunt
disponibile prin Portage - numărul nostru de pachete disponibile
crește zilnic.

Dacă doriți să utilizați sysklogd sau syslog-ng, este recomandat să
instalați și logrotate, deoarece aceste sisteme de logare nu oferă
nici un mecanism de rotire pentru fișierele log.

Pentru a instala un sistem de log la alegerea dumneavoastră, utilizați
emerge pentru a-l instala și adăugați-l în nivelul de execuție default
utilizând rc-update. Următorul exemplu instalează syslog-ng.

Bineînțeles, înlocuiți cu sistemul dumneavoastră de log:

[source,bash]
.Instalarea unui sistem de log
----
# emerge syslog-ng
# rc-update add syslog-ng default
----

==== Opțional: Cron daemon

Următorul este cron daemon. Este opțional și nu este cerut de sistem,
dar este înțelept să instalați unul. Ce este un cron daemon? Un cron
daemon execută comenzile programate. Este foarte util dacă aveți
nevoie să executați regulat anumite comenzi (de exemplu zilnic,
săptămânal sau lunar).

Gentoo oferă trei posibili cron daemons: dcron, fcron și
vixie-cron. Instalarea unuia dintre ei este identică cu instalarea
sistemului de logare. Totuși, dcron și fcron cer o configurare
specială, numită crontab /etc/crontab. Dacă nu știți ce să alegeți
folosiți vixie-cron.

Noi vă oferim vixie-cron pentru instalările fără rețea. Dacă doriți
altă aplicație cron puteți aștepta și îl puteți instala ulterior.

[source,bash]
.Instalare cron daemon
----
# emerge vixie-cron
# rc-update add vixie-cron default
(Numai dacă ai ales dcron sau fcron) # crontab /etc/crontab
----

==== Opțional: Indexare de fișiere

Dacă doriți să vă indexați fișierele din sistemul dumneavoastră pentru
a le localiza rapid folosiți utilitarul locate, pentru a putea folosi
acest utilitar trebuie să instalați sys-apps/mlocate.

[source,bash]
.Instalarea mlocate
----
# emerge mlocate
----

==== Opțional: Accesul de la distanță

Dacă aveți nevoie să vă accesați sistemul de la distanță după
instalare nu uitați să adaugați și sshd la sistemul de execuție
inițial:

[source,bash]
.Adaugarea lui sshd la sistemul de initializare initial
----
# rc-update add sshd default
----

Dacă aveți nevoie de consola serială (ce poate fi folosită în caz de
acces de la distanță), va trebui să decomentați secțiunea ce face
referire la consola serială, puteți face asta deschizând fișierul
'/etc/inittab'.

[source,bash]
.Deschidere pentru editare /etc/inittab
----
# nano -w /etc/inittab
----

Ce ar trebui decomentat pentru consola serială.

Decomentarea consolei seriale din '/etc/inittab':

....
# CONSOLA SERIALĂ
s0:12345:respawn:/sbin/agetty 9600 ttyS0 vt100
s1:12345:respawn:/sbin/agetty 9600 ttyS1 vt100
....

==== Utilitare pentru sistemul de fișiere

În funcție de ce sistem de fișiere folosiți, trebuie să instalați
utilitarele necesare sistemului dumneavoastră (pentru a verifica
integritatea sistemului de fișiere, a crea unele în plus etc.).  Vă
rugăm să notați că deja aveți instalate instrumentele de lucru cu
sistemele de fișiere ext2, ext3 sau ext4 (e2fsprogs) ca parte din
sistem.

Următorul tabel afișează instrumentele pe care trebuie să le instalați
dacă folosiți un anumit tip de sistem de fișiere:

[width="60%",cols="2,2,3",options="header"]
|===
| Sistem de fișiere  |    Utilitar     | Comanda pentru instalare

| XFS                |    xfsprogs     | emerge xfsprogs

| ReiserFS           | reiserfsprogs   | emerge reiserfsprogs

| JFS                |    jfsutils     | emerge jfsutils
|===

==== Utilitare pentru rețea

Dacă nu aveți nevoie de alte utilitare pentru rețea adiționale (cum ar
fi ppp sau un client dhcp), continuați cu Configurarea
Bootloader-ului.

*Opțional: Instalarea unui Client DHCP*

Dacă doriți ca Gentoo să obțină automat o adresă IP pentru interfețele
de rețea, trebuie să instalați dhcpcd (sau orice alt client DHCP --
pentru o listă cu clienți DHCP disponibili consultați
http://www.gentoo.org/doc/en/handbook/handbook-amd64.xml?style=printable&full=1#book_part4_chap3[Retea
Modulară] ) pe sistemul dvs. Dacă nu faceți acest lucru acum, este
posibil să nu vă mai puteți conecta la internet după instalare!

[source,bash]
.Instalarea dhcpcd
----
# emerge dhcpcd
----

*Opțional: Instalarea unui client PPPoE*

Dacă aveți nevoie de ppp pentru a vă conecta la rețea, trebuie să-l
instalați.

[source,bash]
.Instalarea ppp
----
# emerge ppp
----

Acum continuați cu Configurarea aplicației bootloader.

== Capitolul 10

=== Configurarea aplicației bootloader

==== Alegerea

*Introducere*

Acum, kernel-ul este configurat și compilat și fișierele de
configurare ale sistemului sunt completate corect, este timpul să
instalăm un program ce va încărca kernel-ul când porniți sistemul. Un
astfel de program se numește bootloader.

Pentru arhitectura amd64, Gentoo Linux oferă GRUB Legacy și GRUB2.

Dar, înainte de a instala unul dintre aceste aplicații încărcător de
sistem (bootloader), o să vă informăm cum să configurați framebuffer
(presupunând că doriți acest lucru, bineînțeles). Cu framebuffer
puteți rula linia de comandă Linux beneficiind de unele caracteristici
(limitate) grafice (cum ar fi utilizarea imaginii bootsplash pe care
Gentoo o oferă).

*Opțional: Framebuffer*

Dacă v-ați configurat kernel-ul cu suport pentru framebuffer (sau ați
utilizat configurația implicită din genkernel), puteți activa
framebuffer prin adăugarea parametrului vga sau video în configurația
aplicației bootloader (încărcătorul de sistem).

Mai întâi de toate, trebuie să știți ce dispozitiv (device) utilizați
pentru framebuffer. Va trebui să utilizați uvesafb ca driver VESA.

Parametrul video controlează rezoluția și adâncimea de culoare pentru
ecranul framebuffer pentru uvesafb. Așa cum este menționat și în
'/usr/src/linux/Documentation/fb/uvesafb.txt'.

Cele mai folosite opțiuni sunt:


[width="60%",cols="2,8",options="header"]
|===
|Control |Descriere
|ywrap |Presupune că placa grafică își poate realoca memoria consecutiv
(spre ex. să continue de la început când a ajuns la sfârșit)

|mtrr:n |Setează regiștrii MTRR. n poate fi: +
0 - dezactivat +
1 - necache-uit +
2 - modul write-back +
3 - modul write-combining +
4 - modul write-through
|mod |Setează rezoluția, adâncimea de culoare și rata de
reîmprospătare. Spre exemplu, 1024x768-32@85 pentru o rezoluție
de 1024x768, 32 biți adâncimea de culoare și o rata de
reîmprospătare de 85 Hz.
|===

Rezultatul poate fi ceva de genul
video=uvesafb:mtrr:3,ywrap,1024x768-32@85. Rețineți (sau notați-vă)
aceste setări; veți avea nevoie de ele în scurt timp.

Acum, continuați cu instalarea GRUB Legacy sau GRUB2.

==== Implicit: Utilizarea GRUB Legacy

*Înțelegerea terminologiei implementată în GRUB Legacy*

Cea mai critică parte în procesul de înțelegere a aplicației GRUB este
familiarizarea cu modul cum acesta se referă la discuri dure și
partiții. Partiția dumneavoastră de Linux '/dev/sda1' va fi aproape
sigur referită în GRUB ca (hd0,0). Atenție la parantezele din jurul
hd0,0 sunt necesare.

Unitățile de disc dur sunt numerotate hdx (unde x este 0 (zero) pentru
primul disc dur, 1 - pentru al doilea disc dur etc) și partițiile
încep de la zero în loc de unu. Atenție, din nou, la faptul că doar
unitățile de disc dur sunt numerotate, nu și dispozitivele non-atapi
cum ar fi dispozitivele cdrom și cele de înregistrat CD-uri. De
asemenea, aceeași referire există și pentru dispozitivele
SCSI. (Normal, ele sunt numerotate până la numere mai mari decât
drive-urile IDE, exceptând cazul în care BIOS-ul este configurat să
încarce sistemul de pe dispozitivele SCSI). Când configurați în BIOS
să încarce sistemul de pe un disc diferit (spre ex. discul
dumneavoastra. primary slave), acel disc va fi detectat ca hd0.

Presupunând că aveți un hard-disk pe '/dev/sda', un cdrom pe
'/dev/sdb', un cdwriter pe '/dev/sdc', un al doilea disc dur pe
'/dev/sdd' și nici un disc dur SCSI, atunci '/dev/sdd7' devine pentru
GRUB (hd1,6). Ar putea părea înșelător și chiar este, dar așa cum vom
vedea, GRUB-ul oferă un mecanism de completare cu tab la îndemâna
celor care au multe discuri dure și partiții și din acastă cauză s-au
pierdut în schema de numerotare a GRUB-ului.

Obișnuindu-ne cu ideea, este timpul să începem instalarea GRUB-ului.

*Instalarea GRUB Legacy*

Pentru a instala GRUB-ul, trebuie mai întâi să dați comanda emerge.

[source,bash]
.Instalarea GRUB
----
# emerge grub
----

Deși GRUB este acum instalat, tot mai trebuie să îi scriem un fișier
de configurare și să-l instalăm în zona MBR pentru ca GRUB să încarce
(boot-eze) automat noul kernel creat. Creați /boot/grub/grub.conf cu
nano (sau, dacă este cazul, cu alt editor):

[source,bash]
.Crearea /boot/grub/grub.conf
----
# nano -w /boot/grub/grub.conf
----

Acum o să scriem un fișier 'grub.conf'. Aveți grijă să utilizați
imaginea dumneavoastră de kernel și dacă este cazul, imaginea
dumneavoastră *initrd*.

NOTE: Grub alocă din BIOS destinația dispozitivului. Dacă schimbați
setările BIOS-ului dumneavoastră, modul de notare al
dispozitivului dur (hard disk-ului) se va schimba și el. De
exemplu, dacă veți schimba ordinea de încărcare (boot-are) a
dispozitivului, veți fi nevoit să reconfigurați GRUB-ul.

NOTE: Dacă sistemul de fișiere al partiției dumneavoastră rădăcină
este JFS, trebuie să adăugați " ro" în linia de kernel, deoarece
JFS trebuie să-și restaureze log-ul înainte de a permite
montarea în modul read-write (citire-scriere).

Exemplu de 'grub.conf':

....
# Which listing to boot as default. 0 is the first, 1 the second
etc.
default 0
# How many seconds to wait before the default listing is booted.
timeout 30
# Nice, fat splash-image to spice things up :)
# Comment out if you don't have a graphics card installed
splashimage=(hd0,0)/boot/grub/splash.xpm.gz

title Gentoo Linux 3.4.9
# Partition where the kernel image (or operating system) is
located
root (hd0,0)
kernel /boot/kernel-3.4.9-gentoo root=/dev/sda3

title Gentoo Linux 3.4.9 (rescue)
# Partition where the kernel image (or operating system) is
located
root (hd0,0) kernel /boot/kernel-3.4.9-gentoo root=/dev/sda3
init=/bin/bb

# The next four lines are only if you dualboot with a Windows
system.
# In this case, Windows is hosted on /dev/sda6.
title Windows XP
rootnoverify (hd0,5)
makeactive
chainloader +1
....

În cazul în care ați optat pentru initramfs la compilarea kernelului
Linux, atunci trebuie să specificați prin initramfs rădăcina reală a
dispozitivului dumneavoastră.

Exemplu 'grub.conf' cu *initramfs* activat:

....
title Gentoo Linux 3.4.9
root (hd0,0)
kernel /boot/3.4.9 real_root=/dev/sda3
initrd /boot/initramfs-genkernel-amd64-3.4.9-gentoo
....

Dacă utilizați o schemă de partiționare și/sau imagine de kernel
diferită, modificați în consecință. Oricum, asigurați-vă că orice
precedă un device GRUB (cum ar fi (hd0,0)) este relativ la mount point
nu la rădăcină. Cu alte cuvinte, (hd0,0)/grub/splash.xpm.gz este în
realitate '/boot/grub/splash.xpm.gz' deoarece (hd0,0) este /boot.

În plus, dacă alegeți să utilizați o altă schemă de partiționare și nu
ați pus '/boot' pe o partiție separată, prefixul '/boot' utilizat în
exemplele de cod de mai sus este chiar necesar. Dacă ați urmat planul
de partiționare sugerat de noi, prefixul '/boot' nu este necesar, însă
link-ul simbolic boot îl face să funcționeze. Pe scurt, exemplele de
mai sus ar trebuie să funcționeze, indiferent dacă ați utilizat o
partiție separată pentru '/boot' sau nu.

Dacă doriți să introduceți opțiuni adiționale pentru kernel,
adăugați-le la sfârșitul comenzii kernel. Deja avem o opțiune
(root=/dev/sda3 sau real_root=/dev/sda3), dar puteți introduce și
altele, cum ar fi parametrii video și/sau video pentru framebuffer,
așa cum am specificat anterior.

Dacă utilizați o versiune de kernel 2.6.7 sau mai nouă și ați
modificat contactele pe discul dur pentru că BIOS-ul dumneavoastră nu
poate manipula discuri mari, va trebui să adăugați opțiunea
sdx=stroke. Înlocuiți sda cu dispozitivul care necesită această
opțiune.

Utilizatorii genkernel ar trebui să știe că kernel-urile lor
utilizează aceleași opțiuni folosite pentru mediul Installation
CD. Spre exemplu, dacă aveți dispozitive SCSI, ar trebui să adăugați
doscsi ca opțiune de kernel.

Acum salvați fișierul grub.conf și ieșiți. Tot mai trebuie să instalăm
GRUB în zona MBR (Master Boot Record) pentru ca acesta să fie încărcat
automat la pornirea sistemului.

Dezvoltatorii GRUB ne recomandă să utilizăm grub-install. Totuși, dacă
dintr-un motiv grub-install nu funcționează corect, tot mai aveți
soluția să instalați GRUB manual.

Continuați cu Implicit: Setarea GRUB utilizând grub-install sau
Alternativ: Setarea GRUB Utilizând Instrucțiuni Manuale.

*Implicit: Setarea GRUB utilizând grub-install*

Pentru a instala GRUB trebuie să rulați comanda grub-install.  Totuși,
grub-install nu va funcționa ca la carte pentru că ne aflăm într-un
mediu chroot. Trebuie să creăm /etc/mtab ce conține toate sistemele de
fișiere montate. Din fericire, există o soluție simplă pentru a
realiza acest pas, trebuie doar să copiați /proc/mounts ca /etc/mtab,
excluzând linia rootfs, în cazul în care nu ați creat o partiție
separată de boot.  Următoarea comandă va funcționa în ambele cazuri:

[source,bash]
.Crearea /etc/mtab
----
# grep -v rootfs /proc/mounts > /etc/mtab
----

Acum, puteți instala grub, utilizând grub-install:

[source,bash]
.Rularea grub-install
----
# grub-install --no-floppy /dev/sda
----

Dacă aveți mai multe întrebări cu privire la GRUB, vă rugăm să
consultați documentul despre
http://www.gnu.org/software/grub/grub-faq.html[Întrebări Frecvente
despre GRUB] , http://grub.enbug.org/GrubLegacy[GRUB Wiki] sau
citiți informații despre grub în terminalul dumneavoastră.

Continuați cu Repornirea Sistemului.

*Alternativ: Setarea GRUB utilizând instrucțiuni manuale*

Pentru a începe configurarea GRUB, tastați grub. Vi se va afișa grub>,
linia de comandă a grub. Acum, trebuie să tastați comenzile potrivite
pentru a instala GRUB pe disc.

[source,bash]
.Rularea GRUB shell
----
# grub --no-floppy
----

NOTE: Dacă sistemul dvs. nu are dispozitive floppy, adăugați opțiunea
--no-floppy comenzii de mai sus pentru a preveni grub să probeze
dispozitivele floppy (neexistente).

În configurația exemplu, vrem să instalăm GRUB pentru a îl determina
să citească informația de pe partiția de boot '/dev/sda1' și să
instaleze înregistrarea de boot GRUB în zona MBR (Master Boot Record)
a discului, pentru ca primul lucru afișat în momentul pornirii
sistemului să fie promptul GRUB.

Bineînțeles, dacă nu ați urmat configurația exemplu din timpul
instalării, schimbați comenzile în concordanță. Mecanismul de
completare prin tab a aplicației GRUB poate fi utilizat pentru a-l
instala.

Spre exemplu, dacă tastați "root (" urmat de un TAB, vi se va afișa o
listă de dispozitive (cum ar fi hd0). Dacă tastați "root (hd0," urmat
de un TAB, vi se va afișa o listă cu partițiile disponibile din care
să alegeți (cum ar fi hd0,0). Prin utilizarea completării cu tab,
setarea GRUB nu ar trebui să fie așa de complicată.

Acum, haideți, configurați GRUB, da? :-)

[source,bash]
.Instalarea GRUB în zona MBR
----
grub> root (hd0,0) #Specificați unde se află partiția dvs. /boot
grub> setup (hd0) #Instalați GRUB în zona MBR
grub> quit #Ieșiți din GRUB shell
----

NOTE: Dacă doriți să instalați GRUB într-o anumită zonă în loc de MBR,
va trebui să modificați comanda setup pentru a indica partiția
corespunzătoare. Spre exemplu, dacă doriți să instalați GRUB în
/dev/sda3, atunci comanda devine setup (hd0,2). Totuși, puțini
utilizatori doresc acest lucru.

Dacă aveți mai multe întrebări cu privire la GRUB, vă rugăm să
consultați documentul despre
http://www.gnu.org/software/grub/grub-faq.html[Întrebări Frecvente
despre GRUB] , http://grub.enbug.org/GrubLegacy[GRUB Wiki] sau
citiți informații despre grub în terminalul dumneavoastră.

Continuați cu Repornirea Sistemului.

==== Instalare GRUB2

*Despre GRUB2*

GRUB2 este un încărcător de sistem ce suportă majoritatea sistemelor
din zilele noastre. Are ca scop înlocuirea vechiului încărcător de
sistem GRUB (referire la GRUB Legacy). GRUB2 are o bază de cod total
separată de GRUB Legacy și are caracteristici cum ar fi o nouă sintaxă
de tip înveliș (eng. shell ) care permite capabilități avansate de
scripting. Cei ce folosesc GRUB Legacy sunt încurajați să migreze
către GRUB2.

Trecerea la GRUB 2 ar putea fi benefică din moment ce permite :

- încărcarea (eng. booting) de pe platforme UEFI;

- încărcarea (eng. booting) de pe dispozitive partiționate GPT
fără să fie nevoie de vreun MBR hibrid, cu toate că poate fi
folosit din motive de compatibilitate/portabilitate;

- încărcarea (eng. booting) directă de pe un volum logic ca
suportul LVM2;

- încărcarea de pe un suport raid (DM-RAID), pentru RAID [0?] 1,
4, 5, 6, 9 și 10 [sau 1x?];

- încărcarea de pe dispozitive criptate, probabil LUKS, din cauza
documentației inexistente și în ciuda faptului că modulele
cypher/hash sunt prezente acolo: deci nu există un ghid despre
cum se face în acest moment.

*Instalarea propriu-zisă*

Momentan GRUB2 este mascat în Portage. O intrare în fișierul
'/etc/portage/package.keywords' este necesară pentru a putea fi
instalat.

Editarea fișierului '/etc/portage/package.keywords':

....
sys-boot/grub:2 #aceasta linie trebuie adăugată în fișier pentru
a putea instala GRUB2
....

În mod implicit, GRUB2 va ghicii platforma folosita implicit, dar dacă
doriți setarea manuala sau explicita a platformei o puteți face setând
GRUB_PLATFORMS în make.conf.

Setarea variabilei GRUB_PLATFORMS în '/etc/portage/make.conf':

....
# Standard PC (BIOS)
GRUB_PLATFORMS="pc"

# UEFI on amd64
GRUB_PLATFORMS="efi-64"

# UEFI and PC
GRUB_PLATFORMS="efi-64 pc"
....

Instalarea cu ajutorul lui emerge.

[source,bash]
----
root # emerge --ask sys-boot/grub:2
----

*Instalarea unei imagini de boot*

În cazul în care aveți o partiție de /boot, montați-o.

[source,bash]
----
root # mount /boot
----

Dacă folosiți platforma EFI, montați-vă sistemul de volum (partiția)
în /boot/efi. Aceasta trebuie sa fie un volum (o partiție) de tip FAT
ce va conține un subdirector EFI.

[source,bash]
----
root # mount /boot/efi
----

Rulați utilitarul grub2-install pentru a copia fișierele relevante în
/boot/grub2. Pentru platforma PC, de asemenea acesta instalează o
imagine boot în master boot record (MBR) sau sectorul unei partiții.

grub2-install acceptă o opțiune de tip --target pentru a putea
specifica pentru ce platforma/CPU să se instaleze. Dacă nu
specificați, grub2-install va presupune ce platforma sa aleagă: pentru
amd64/x86 va folosi în mod implicit „i386-pc“.


[source,bash]
.Instalarea în MBR
----
root # grub2-install /dev/sda
Installation finished. No error reported.
----

[source,bash]
.Instalarea pe o partitie (nerecomandat)
----
root # grub2-install /dev/sda1
Installation finished. No error reported.
----

[source,bash]
.Instalarea pe EFI
----
root # grub2-install --target=x86_64-efi
Installation finished. No error reported.
----

*Configurarea automată*

GRUB2 permite configurarea automată prin folosirea programului
grub2-mkconfig care va genera un fișier de configurare.

grub2-mkconfig va genera fișierul de configurare bazat pe secțiuni de
șabloane aflate în /etc/grub.d. Iar șabloanele implicite ar trebui să
acopere cele mai frecvente setări de boot.

[source,bash]
----
user $ ls /etc/grub.d
00_header 10_linux 20_linux_xen 30_os-prober 40_custom 41_custom README
----

Comportamentul șabloanelor poate fi controlat prin stabilirea
variabilelor în /etc/default/grub. Pentru referințe consultați
http://www.gnu.org/software/grub/manual/html_node/Simple-configuration.html[manualul
GRUB-ului] .

*Numirea kernelului*

Ca GRUB2 să detecteze kernelurile Linux, kernelurile ar trebui numite
vmlinuz-version sau kernel-version.

De exemplu:

....
./boot/vmlinuz-3.4.3
/boot/kernel-2.6.39-gentoo
....

Dacă folosiți initramfs, el ar trebui numit astfel:
initramfs-version.img sau initrd-version.img. Denumirile fișierelor
generate de genkernel, de asemenea vor fi funcționale.

....
./boot/initramfs-3.4.3.img
/boot/initramfs-genkernel-x86_64-2.6.39-gentoo
....

[source,bash]
.Generarea fișierului de configurarea grub.cfg
----
root # mount /boot
root # grub2-mkconfig -o /boot/grub2/grub.cfg
Generating grub.cfg ...
Found linux image: /boot/vmlinuz-3.2.9
done
----

*Decompresia kernelului în mod discret*

Pentru a decompresa kernelul Linux în mod discret trebuie să aveți în
fișierul /etc/default/grub următoarea linie.

Fișierul '/etc/default/grub':

....
GRUB_CMDLINE_LINUX_DEFAULT="quiet"
....

*systemd*

Pentru a încărca systemd cu ajutorul lui grub2 asigurați-vă că
următoarea linie va arăta ca mai jos.

Fișierul '/etc/default/grub':

....
GRUB_CMDLINE_LINUX_DEFAULT="init=/usr/lib/systemd/systemd"
....

*Încărcarea Windows 7*

[source,bash]
----
root # emerge os-prober ntfs3g
----

După rulați comanda grub2-mkconfig -o /boot/grub2/grub.cfg. Dacă ați
compilat kernelul linux cu suport fuse, reporniți sistemul apoi
rerulați grub2-mkconfig.

*Configurarea manuală*

În loc să rulați grub2-mkconfig, un grub.conf simplu poate fi
convertit ușor să se potrivească pentru utilizarea în grub.cfg.

[width="60%",cols="2",options="header"]
|===
|grub.conf (Grub Legacy)
|grub.cfg (GRUB2)

| timeout 5 +
title Gentoo Linux 3.2.12 +
root (hd0,0) +
kernel /boot/kernel-3.2.12-gentoo +
root=/dev/sda3
|timeout=5 +
menuentry 'Gentoo Linux 3.2.12' { +
root=hd0,1 +
linux /boot/kernel-3.2.12-gentoo +
root=/dev/sda3 +
}
|===

Pentru mai multe informații privitoare la instalarea lui GRUB2
consultați wiki https://wiki.gentoo.org/wiki/GRUB2[GRUB2].

Continuați cu Finalizarea Instalării Gentoo.

== Capitolul 11

=== Finalizarea instalării Gentoo

==== Administrarea utilizatorilor de sistem

*Adăugarea unui utilizator pentru întrebuințarea zilnică*

Utilizarea contului de root pe un sistem Unix/Linux este periculasă și
trebuie evitată cât mai mult. De aceea se recomandă insistent să
adăugați un utilizator pentru folosirea zilnică.  Grupurile în care
utilizatorul este membru definesc activitățile pe care le poate
efectua. Următorul tabel afișează un număr de grupuri importante pe
care le puteți utiliza:


[width="80%",cols="1,8",options="header"]
|===
| Grup     |Descriere

| audio    |pentru a avea acces la dispozitivele audio

| cdrom    |pentru a putea avea acces direct la dispozitivele cdrom

| floppy   |pentru a putea avea acces direct la dispozitivele floppy

| games    |pentru a putea rula jocuri

| portage  |pentru a putea rula emerge --pretend ca utilizator normal

| usb      |pentru a putea accesa dispozitivele USB

|plugdev   |pentru a putea efectua mount și utiliza dispozitivele conectabile, cum ar fi camerele digitale și memoriile USB

|video     |pentru a putea accesa componentele hardware de captură video și a putea beneficia de accelerare hardware

|wheel    |pentru a putea utiliza su
|===

De exemplu, pentru a crea un utilizator john care este membru al
grupurilor wheel, users și audio trebuie să efectuați login ca root
(numai utilizatorul root pot crea utilizatori) și să rulați *useradd*:

[source,bash]
.Adăugarea unui user pentru întrebuințarea zilnică
----
#su -
Password: (Parola dvs. pentru root)

# useradd -m -G users,wheel,audio -s /bin/bash john
# passwd john
Password: (Introduceți parola pentru john)
Re-enter password: (Reintroduceți parola pentru verificare)
----

Dacă acest utilizator are nevoie să facă anumite operații ca root, se
poate utiliza comanda su - pentru a primi privilegii de root, doar
temporar. O altă metodă este pachetul sudo care, dacă este configurat
bine, este foarte sigur.

==== Ștergerea arhivei stage3 din sistem

Acum că ați finalizat instalarea Gentoo-lui, dacă totul a decurs
normal după repornirea sistemului, puteți șterge arhiva stage3
descărcată pe discul dumneavoastră. Țineți minte, ea a fost descărcată
în directorul '/' (rădăcina).

[source,bash]
.Ștergerea arhivei stage3 din sistem
----
# rm /stage3-*.tar.bz2*
----

Felicitări aveți un sistem Gentoo Linux funcțional. Dar ce o să facem
de aici înainte?

Urmează instalarea unui mediu Desktop.

Continuați cu Ghid de configurare pentru Xorg.

== Capitolul 12

=== Ghid de instalare și configurare pentru Xorg

==== Ce este serverul X Window

*Modul grafic vs. Modul text*

Utilizatorul mediu se sperie la gândul de a fi nevoit să scrie
comenzi. De ce să nu poată folosi un mediu grafic după cum ar vrea,
având în vedere libertatea pusă la dispoziție de Gentoo (Și de
Gnu/Linux în general)? Sigur că se poate. Linuxul oferă o largă
varietate de interfețe și medii grafice care arată foarte bine, și
care se pot instala peste aplicațiile care rulează în general în mod
text.

Aceasta este una dintre surprizele cu care se întâlnesc noii
utilizatori: o interfață grafică nu este decât o aplicație care
rulează în mod obișnuit și nu face parte din kernelul Linux sau din
componentele sistemului de operare, ci este doar o unealtă care
folosește pe deplin abilitățile grafice ale unui calculator.

Deoarece standardele sunt importante, și pentru desenarea și mișcarea
ferestrelor pe ecran, pentru interacțiunea cu utilizatorul prin
intermediul tastaturii și mouse-ului și pentru alte aspecte de bază
ale unei interfețe grafice a fost creat un standard. Acesta poartă
numele de X Window System, abreviat X11 sau doar X. Acesta este
folosit în Unix, BSD, Linux și alte clone de Unix.

Una din aplicațiile care oferă utilizatorilor Linux-ului posibilitatea
rulării unei interfețe grafice și care respectă standardul X11 este
Xorg-X11, o ramură a proiectului XFree86.  XFree86 a hotărât să
folosească o licență care s-ar putea să nu fie compatibilă cu licența
GPL, și astfel este recomandată folosirea Xorg ca
înlocuitor. Structura Portage oficială nu mai oferă nici un pachet
XFree86.

*Proiectul X.org*

Proiectul http://www.x.org[X.org] a creat și dezvoltă o implementare
open-source distribuită în mod liber a X Windows System. Este deci o
infrastructură desktop open-source bazată pe standardul X11.

Xorg oferă o interfață între componentele hardware și aplicațiile
software care rulează în mod grafic. În plus, Xorg mai are capacități
de lucru în rețea, adică permite rularea unei aplicații pe un sistem
și vizualizarea sa pe un altul.

==== Instalare Xorg

*Utilizarea emerge*

Gata cu introducerea, să trecem la treabă. Pentru a instala Xorg în
Gentoo este suficientă comanda emerge xorg-x11. Instalarea Xorg
durează destul de mult, deci puteți între timp sa vă găsiți altceva de
făcut.

[source,bash]
.Instalarea Xorg
----
# emerge xorg-x11
----

După ce instalarea s-a terminat, s-ar putea să fie nevoie să
reinițializați unele variabile de mediu, înainte de a trece mai
departe. Este suficientă rularea comenzii env-update urmată de source
'/etc/profile'. Aceasta nu deteriorează sistemul în nici un fel.

[source,bash]
.Reinițializarea variabilelor de mediu
----
# env-update
# source /etc/profile
----

==== Configurare Xorg

*Fișierul xorg.conf*

Fișierul de configurare al Xorg este numit xorg.conf și se află în
directorul '/etc/X11'.  Xorg oferă un exemplu de fișier de configurare
aflat în /etc/X11/xorg.conf.example. Acesta este comentat foarte
intens, dar dacă este nevoie de mai multe informații privind sintaxa
nu ezitați să citiți pagina de manual:

[source,bash]
.Pagina de manual a xorg.conf
----
# man 5 xorg.conf
----

Lectură plăcută pentru cei care doresc acest lucru, însă noi o să
continuăm configurarea folosind unelte care vor modifica automat
fișierul xorg.conf făcând treaba cea mai dificilă în locul nostru.

*Implicit: Generarea automată a fișierului xorg.conf*

Xorg însuși poate să detecteze cei mai mulți parametri în locul
nostru. În cele mai multe cazuri o să aveam de modificat numai unele
linii care vor face ca interfața să ruleze la rezoluția dorită de
către noi. Dacă sunteți interesat de unele setări mai de profunzime,
verificați resursele oferite la sfârșitul acestui capitol. Să încercăm
să generăm mai întâi un fișier de configurare Xorg (sperăm,
funcțional).

[source,bash]
.Generarea fișierului xorg.conf
----
# Xorg -configure
----

Citiți ultimele linii afișate pe ecran după ce Xorg a terminat de
analizat componentele hardware. Dacă acolo scrie că Xorg a eșuat în
timpul verificării, veți fi forțat să editați în mod manual fișierul
xorg.conf. În caz contrar, se va afișa un mesaj care vă spune că
fișierul /root/xorg.conf.new a fost scris și este gata pentru a fi
testat. Așa că haideți să îl testăm.

[source,bash]
.Testarea fișierului xorg.conf.new
----
# X -config /root/xorg.conf.new
----

Dacă totul merge bine, ar trebui să vedeți un model cu alb și
negru. Verificați dacă vă funcționează dispozitivul mouse și dacă
rezoluția este corectă. Este posibil să nu puteți deduce rezoluția
exactă, dar ar trebui să puteți observa dacă este prea joasă. Puteți
ieși în orice moment prin apăsarea Ctrl-Alt-Backspace.

*Metodă alternativă: Generarea semi-automată a fișierului xorg.conf*

Xorg conține un utilitar numit xorgconfig care vă va întreba unele
informații privitoare la hardware-ul dumneavoastră. (placa grafică,
tastatura, ...) și creează un fișier xorg.conf pe baza acestor
informații.

[source,bash]
.Generarea semi-automată a fișierului xorg.conf
----
# xorgconfig
----

Un alt utilitar, de asemenea oferit de Xorg, este xorgcfg, ce va
încerca, mai întâi, să ruleze Xorg -configure și apoi să pornească
aplicația server X pentru mai multe optimizări finale.

[source,bash]
.Utilizare xorgcfg
----
# xorgcfg
Dacă aplicația X nu poate rula sau configurarea returnează
eroare, încercați
# xorgcfg -textmode
----

*Suprascriere xorg.conf*

Mai întâi copiem fișierul xorg.conf.new peste fișierul
'/etc/X11/xorg.conf' pentru a nu fi nevoiți să rulăm tot timpul
comanda X -config. Lansarea cu startx este mult mai ușoară.

[source,bash]
.Suprascriere xorg.conf
----
# cp /root/xorg.conf.new /etc/X11/xorg.conf
----

*Utilizare startx*

Acum, încercați lansarea startx pentru a porni aplicația server
X. startx este un fișier script ce execută o sesiune X, respectiv
pornește aplicațiile server X și unele aplicații grafice peste
acestea. Acesta decide care aplicații trebuie rulate, urmând
următoarea logică:

- Dacă un fișier denumit .xinitrc există în directorul home, va
executa comenzile conținute în acesta.

- Altfel, va citi valoarea variabilei XSESSION și va executa una din
sesiunile disponibile în /etc/X11/Sessions/, corespunzător (puteți
seta valoarea variabilei XSESSION în /etc/rc.conf pentru a o face
implicită pentru toți utilizatorii din sistem).

- Dacă toate acțiunile de mai sus returnează eroare, va executa un
mediu grafic simplu, de obicei twm.

[source,bash]
.Pornire Xorg
----
# startx
----

Dacă se încarcă un mediu grafic urât, repulsiv, deformat, acela este
twm. Pentru a încheia sesiunea twm, tastați exit sau Ctrl-D în
ferestrele xterm. Puteți, de asemenea, să opriți sesiunea X, utilizând
combinația Ctrl-Alt-Backspace. Oricum, aceasta va determina ieșirea
din mediul X într-un mod necorespunzător, ceva ce nu veți dori
întotdeauna. Totuși, nu este chiar atât de rău.

==== Optimizare xorg.conf

*Setarea rezoluției*

În cazul în care credeți că rezoluția este nepotrivită, veți fi nevoit
să verificați două secțiuni ale configurației. Mai întâi aveți
secțiunea Screen unde sunt listate rezoluțiile în care va rula
serverul X, dacă există. În mod implicit, aceasta nu conține nici o
rezoluție, caz în care Xorg estimează rezoluțiile bazându-se pe
informațiile din cea de-a doua secțiune, Monitor.

Tot ce face Xorg este verificarea setărilor HorizSync și VertRefresh
din secțiunea Monitor pentru a obține rezoluții valide. Deocamdată
lăsăm aceste setări așa cum sunt. Doar dacă schimbările din secțiunea
Screen nu funcționează (o să le descrie mai jos) atunci va trebui să
luați specificațiile monitorului din cartea tehnică și să le scrieți
în fișier. Puteți însă să folosiți un program care le determină în mod
automat, cum ar fi 'sys-apps/ddcxinfo-knoppix'.

ATENTION: Nu schimbați valorile acestor variabile fără a ști
specificațiile monitorului. Aceasta poate duce în cel mai
fericit caz la erori de sincronizare, dacă nu cumva chiar și
la arderea monitorului.

Acum, să schimbăm rezoluțiile. În exemplul următor în
'/etc/X11/xorg.conf' adăugăm liniile Modes și respectiv DefaultDepth
pentru ca serverul X să pornească în mod implicit în rezoluția
1024x768 cu adâncimea de culoare de 24 de biți. Nu vă cramponați pe
valorile date, acestea sunt exemple, și este foarte probabil ca aceste
valori să difere de cele setate în sistemul dumneavoastră.

Schimbarea secțiunii Screen din '/etc/X11/xorg.conf':

....
Section "Screen"
Identifier "Default Screen"
Device "S3 Inc. ProSavage KN133 [Twister K]"
Monitor "Generic Monitor"
DefaultDepth 24
# Am eliminat din text pentru a-l face mai lizibil
SubSection "Display"
    Depth 24
    Modes "1024x768"
    EndSubSection
EndSection
....

Rulați serverul X (startx) pentru a vedea dacă acesta folosește
rezoluția dorită.

*Configurarea tastaturii*

Pentru a face astfel încât X să folosească o tastatură localizată
căutați secțiunea InputDevice, în care care vă este configurată
tastatura și adăugați opțiunea XkbLayout care să indice schema de
tastatură pe care o doriți. Trebuie doar să înlocuiți codul țării cu
cel dorit de dumneavoastră:

Schimbarea schemei de tastatură:

....
Section "InputDevice"
    Identifier "Generic Keyboard"
    Driver "keyboard"
    Option "CoreKeyboard"
    Option "XkbRules" "xorg"
    Option "XkbModel" "pc105"
    Option "XkbLayout" "ro"
EndSection
....

*Configurarea mouse-ului*

Dacă mouse-ul nu vă funcționează, veți fi nevoit mai întâi să aflați
dacă este compatibil cu kernel-ul pe care îl aveți.  Dispozitivele
mouse sunt detectate de către kernel ca '/dev/input/mouse0' (sau
'/dev/input/mice' dacă doriți să utilizați mai multe dispozitive
mouse). În unele cazuri, este utilizat '/dev/psaux'. Orice mouse ați
avea, puteți verifica dacă aceste fișiere de tip device vă reprezintă
mouse-ul citind valorile aflate în acestea în timp ce mișcați
mouse-ul. De obicei, veți observa niște caractere ciudate pe
ecran. Pentru a ieși din test apăsați Ctrl-C.

[source,bash]
.Verificarea fișierelor de tip device
----
# cat /dev/input/mouse0
(Apăsați Ctrl-C pentru a termina)
----

Dacă mouse-ul nu este detectat verificați dacă toate modulele necesare
sunt încărcate în kernel.

Dacă mouse-ul este detectat, introduceți dispozitivul la care este
conectat în secțiunea InputDevice corespunzătoare. În exemplul următor
o să setam alte două opțiuni: Protocol (în care scriem ce protocol de
mouse va fi folosit -- majoritatea utilizatorilor vor scrie aici PS/2
sau IMPS/2) și ZAxisMapping (care permite folosirea rotiței de scroll,
dacă există):

Schimbarea setărilor mouse-ului în Xorg:

....
Section "InputDevice"
    Identifier "TouchPad Mouse"
    Driver "mouse"
    Option "CorePointer"
    Option "Device" "/dev/input/mouse0"
    Option "Protocol" "IMPS/2"
    Option "ZAxisMapping" "4 5"
EndSection
....

Rulați *startx* și bucurați-vă de rezultat. Felicitări, acum (sperăm
să) aveți în sistem un server Xorg funcțional. Următorul pas este
înlăturarea twm, managerul de ferestre urât amintit la început și
înlocuirea sa cu un altul mai frumos și mai funcțional sau de ce nu
chiar cu un mediu desktop complet cum ar fi KDE sau GNOME, care însă
nu va fi detaliată în acest ghid de instalare.

==== Resurse

*Crearea și editarea fișierului xorg.conf*

Întâi de toate, man 5 xorg.conf oferă un ghid rapid și destul de
complet al sintaxei fișierului de configurare. Este bine ca acesta să
fie deschis într-un terminal în timp ce editați fișierul de
configurare.

O altă sursă de informații este directorul /usr/X11R6/lib/X11/doc unde
se pot găsi diferite fișiere README pentru unele cipseturi grafice.

Internetul constituie o sursă imensă de documentații privitoare la
editarea fișierului xorg.conf. O să vă oferim aici doar câteva dintre
ele. Mai întâi încercați Google, unde puteți găsi multe informații,
căutând xorg.conf sau XF86Config (fișierul de configurări al
proiectului XFree86), cele două fișiere au aceeași sintaxă pentru
majoritatea opțiunilor. Veți găsi mai multe surse căutând informații
despre XF86Config.

Medii Grafice

1. Gnome

2. KDE

3. Xfce

== Capitolul 13

=== Mediile grafice expuse în manual pentru instalare

Acest ghid vă va explica cum să instalați un mediu grafic (KDE, Gnome,
XFCE) pe un sistem stabil Gentoo amd64.

*Cum setăm flagurile necesare mediului grafic ales?*

Puteți efectua rapid setările necesare USE flags activând profilul
necesar în Portage:

[source,bash]
----
# eselect profile list
[1] default/linux/amd64/10.0
[2] default/linux/amd64/10.0/selinux
[3] default/linux/amd64/10.0/desktop
[4] default/linux/amd64/10.0/desktop/gnome *
[5] default/linux/amd64/10.0/desktop/kde
[6] default/linux/amd64/10.0/developer
[7] default/linux/amd64/10.0/no-multilib
[8] default/linux/amd64/10.0/server
[9] hardened/linux/amd64
[10] hardened/linux/amd64/selinux
[11] hardened/linux/amd64/no-multilib
[12] hardened/linux/amd64/no-multilib/selinux
----

În acest exemplu, profilul #4 este profilul gnome, așadar îl putem
activa prin comanda:

[source,bash]
----
# eselect profile set 4
----

Dacă se dorește instalarea KDE-ului se setează profilul #5, iar pentru
XFCE sau alt mediu de lucru se folosește profilul #3. Iată câteva
exemple:

- pentru KDE

[source,bash]
----
eselect profile set 5
----

- pentru XFCE

[source,bash]
----
eselect profile set 3
----

Gentoo are trei profile pentru mediile grafice: unul pentru KDE, unul
pentru Gnome și un profil generalist pentru restul mediilor
grafice. Pentru mediile grafice ce nu au un profil personal se
folosește profilul desktop.

==== Mediul grafic Gnome

GNOME este un mediu desktop gratuit pentru sisteme compatibile
UNIX. Este software (open source), sub licența liberă GPL (anumite
biblioteci și toolkitul GTK+ sunt sub licența LGPL).  Este mediul
standard de lucru pe un număr mare de distribuții Linux (Ubuntu,
Fedora, Red Hat etc.) și pe sistemele UNIX sau UNIX-like.

GNOME a apărut în 1997, autorul inițial fiind Miguel de Icaza.
Proiectul a fost început ca urmare a utilizării de către KDE a
toolkit-ului Qt, care la vremea respectivă nu era open source, ducând
la limitări asupra a ceea ce putea fi programat pentru KDE, și la
posibilitatea ca, în cazul în care Qt își schimbă strategia, KDE să nu
mai poată fi folosit legal. Acest lucru nu mai este o problemă, Qt
este software liber astăzi, dar atât Gnome cât și KDE continuă a se
dezvolta, fiecare proiect având obiective diferite. KDE și GNOME
colaborează în cadrul proiectului Free Desktop, pentru a asigura
standardizarea în sisteme Unix/Linux.

Pe un sistem cu depozitul stabil activ, emerge gnome va instala Gnome
2, versiunea stabilă. Pentru a instala Gnome 3 trebuie să editați
fișierul /etc/portage/packages.keywords și să adăugați următoarea
linie gnome-base/gnome ~amd64, apoi salvați fișierul.  După ce ați
terminat de editat fișierul /etc/portage/packages.keywords puteți rula
comanda emerge gnome care vă va instala Gnome 3.

[source,bash]
.Instalare Gnome 2
----
# emerge gnome
----

[source,bash]
.Instalare Gnome 3
----
# nano /etc/portage/packages.keywords
(adăugați la sfârșitul fișierului)
gnome-base/gnome ~amd64
(salvați fișierul apăsând concomitent tastele CTRL+O, CTRL+X)
(rulați următoarea comanda pentru a instala gnome 3)
# emerge gnome
----

Vreți să instalați un Gnome minimal?

Înlocuiți comanda emerge gnome cu emerge gnome-light.

Recomand această metoda doar în cazul în care vreți să folosiți
Gnome 2.

Următoarea operațiune imediat după instalarea mediului grafic
Gnome este actualizarea variabilelor de mediu.

[source,bash]
.Actualizarea variabilelor de mediu
----
# env-update && source /etc/profile
----

Pentru funcționare, Gnome are nevoie ca serviciul dbus să fie
pornit. Iată cum pornim serviciul dbus și îl adăugăm la procesele de
pornire ale sistemului.

[source,bash]
----
dbus - pornirea și adăugarea la procesele de pornire a sistemului
# /etc/init.d/dbus start
# rc-update add dbus default
----

Verificați dacă există grupul plugdev. Dacă există asigurați-vă că
faceți parte din acest grup, deși acest lucru nu e obligatoriu. Puteți
sări peste pasul acesta dacă doriți.

[source,bash]
.Adăugarea utilizatorului la grupul plugdev
----
# gpasswd -a utilizatorul-dvs plugdev
----

Unde utilizatorul-dvs este utilizatorul creat de dumneavoastră pentru
activitățile zilnice.

Pentru a avea parte de logare în interfața grafică fără a tasta
comenzi în TTY cel mai convenabilă este instalarea unui manager pentru
mediul grafic ce poartă numele de Display Manager (DM).

În cazul mediului grafic Gnome recomandăm instalarea lui GDM ca
manager al mediului grafic.

[source,bash]
.Instalare GDM
----
# emerge gdm
----

Dacă vreți ca display manager-ul să pornească imediat după
inițializarea sistemului de operare Gentoo trebuie să adăugați
scriptul XDM la procesele de inițializare, pe nivelul de inițializare
implicit. Ca să faceți lucrul acesta xdm trebuie să fie instalat în
sistem. În cazul în care xdm nu este instalat vă rugăm să folosiți
emerge pentru a-l instala.

[source,bash]
.Instalare XDM
----
# emerge xdm
----

[source,bash]
.Adăugare XDM la procesul de inițializare
----
# rc-update add xdm default
----

Acum, editați fișierul /etc/conf.d/xdm în care modificați variabila
DISPLAYMANAGER în modul următor: DISPLAYMANAGER="gdm" .

==== Mediul grafic KDE

KDE este un mediu grafic foarte puternic și util pentru calculatoarele
care au la bază Unix.

*Versiuni disponibile*

KDE SC 4 este versiunea KDE menținută actual în depozitele testing. De
asemenea în Portage există o versiune stabilă și ar mai putea fi una
(sau mai multe) versiuni mai puțin stabile. De regulă noile versiuni
trec în stadiul de versiune stabilă la aproximativ o lună. Adițional,
KDE upstream pune la dispoziție http://quickgit.kde.org/[depozitele
live git].  Echipa KDE pune la dispoziție cele mai recente versiuni
KDE prin
http://git.overlays.gentoo.org/gitweb/?p=proj/kde.git;a=summary[kde
overlay].

Alegeți versiunea KDE SC care vi se potrivește:

[width="80%",cols="4,2,6",options="header"]
|===
|KDE SC versiune |Depozit |Status

|KDE SC 4.10.5 |Portage |Stabil pentru amd64, ppc, ppc64 și x86; versiune de testare pentru arm.

|KDE SC 4.11.0 |Portage |Versiune de test pentru amd64, arm, ppc, ppc64 și x86.

|KDE SC 4.11 stable branch |kde overlay |Versiune Live.

|KDE SC master |kde overlay |Versiune Live.
|===

NOTE: Dacă rulați KDE PIM și vreți să faceți upgrade de la versiunea
4.4 la 4.10, vă rugăm să vă uitați pe
http://wiki.gentoo.org/wiki/KDE/KDEPIM-4.7_upgrade[KDE PIM 4.7
Upgrade Guide] mai întâi (încă se aplică la versiunea 4.10). Dacă
însă doriți să rămâneți la KDE PIM 4.4 puteți masca
http://www.gentoo.org/proj/en/desktop/kde/kdepim-4.7-mask.txt[KDE
PIM 4.10].

*Modificări/Adăugări necesare*

*Profil*

Profilul Desktop a fost împărțit în subprofilele KDE și GNOME .  Acest
lucru reprezintă eliminarea KDE și GNOME USE flags din profilul de
baza desktop și punerea lor în subprofiluri. Alegerea unui profil nu
vă limitează la folosirea doar a unui mediu grafic. Pentru a alege
profilul care vi se potrivește, rulați

[source,bash]
----
root # eselect profile list
----

pentru a vizualiza lista de profiluri, și

[source,bash]
----
root # eselect profile set X
----

unde X este numărul profilului pe care doriți să îl selectați.  Pentru
un mediu grafic complet KDE, este recomandat să alegeți desktop/kde ,
care este configurat specific pentru KDE.

*Servicii*

Înainte să instalați KDE SC este recomandată setarea câtorva
servicii. O pare dintre acestea sunt setate automat dacă folosiți
profilul desktop/kde sau desktop. Ar trebui de asemenea să folosiți:

- ConsoleKit: Oferă acces la framework-ul ConsoleKit pentru a defini
și monitoriza utilizatorii, sesiunile de logare și locurile.

- D-Bus: Permite utilizarea D-Bus message bus system.

- polkit: Activează frameworkul polkit pentru controlul autorizațiilor
pentru majoritatea serviciile de sistem.

- udev: Activează suport pentru udev alocarea dinamica și persistentă
a numelor pentru dispozitivele Linux.

- udisks2: Activează suportul pentru diferite servicii de stocare.

*Instalare*

NOTE: Dacă faceți actualizare, vă rugăm să verificați
http://wiki.gentoo.org/wiki/KDE/upgrade[subpagina de
actualizare].

NOTE: Pentru versiunile uitați-vă pe articolul
http://wiki.gentoo.org/wiki/KDE/Overlay[kde overlay].

*Pachete*

În Gentoo sunt câteva pachete care ar putea instala mediul grafic KDE:

- http://packages.gentoo.org/package/kde-base/kde-meta[kde-base/kde-meta], pentru mediul complet KDE.

- http://packages.gentoo.org/package/kde-base/kdebase-meta[kde-base/kdebase-meta], pentru un mediu de bază KDE.

- http://packages.gentoo.org/package/kde-base/kdebase-startkde[kde-base/kdebase-startkde], un mediu minimal, nesuportat oficial pentru KDE (fără KDE plasma și
alte creații).

[source,bash]
----
root # emerge --ask kdebase-meta
----


De asemenea sunt alte meta-pachete care pot fi instalate să
întregească gama KDE:

- http://packages.gentoo.org/package/kde-base/kdeaccessibility-meta[kde-base/kdeaccessibility-meta] : Aplicații de accesibilitate și utilitate.

- http://packages.gentoo.org/package/kde-base/kdeadmin-meta[kde-base/kdeadmin-meta] : Unelte de administrare, care ajută la menținerea și
administrarea sistemului.

- http://packages.gentoo.org/package/kde-base/kdeartwork-meta[kde-base/kdeartwork-meta] : Diferite teme, economizatoare de ecran, etc.

- http://packages.gentoo.org/package/kde-base/kdebindings-meta[kde-base/kdebindings-meta] : Suport pentru diferite limbi.

- http://packages.gentoo.org/package/kde-base/kdeedu-meta[kde-base/kdeedu-meta]
: Aplicații pentru educație și jocuri.

- http://packages.gentoo.org/package/kde-base/kdegames-meta[kde-base/kdegames-meta] : Jocuri standard pentru mediu grafic.

- http://packages.gentoo.org/package/kde-base/kdegraphics-meta[kde-base/kdegraphics-meta] : Aplicații grafice pentru vizualizat poze, modificat poze,
etc.

- http://packages.gentoo.org/package/kde-base/kdemultimedia-meta[kde-base/kdemultimedia-meta]] : Aplicații de redare audio/video.

- http://packages.gentoo.org/package/kde-base/kdenetwork-meta[kde-base/kdenetwork-meta] : Utilitare de rețea și servicii VNC.

- http://packages.gentoo.org/package/kde-base/kdepim-meta[kde-base/kdepim-meta]
: Aplicații PIM cum ar fi emailer, addressbook, organizer, etc.

- http://packages.gentoo.org/package/kde-base/kdesdk-meta[kde-base/kdesdk-meta]
: Diferite unelte pentru dezvoltare.

- http://packages.gentoo.org/package/kde-base/kdetoys-meta[kde-base/kdetoys-meta] : Aplicații gen jucării.

- http://packages.gentoo.org/package/kde-base/kdeutils-meta[kde-base/kdeutils-meta] : Aplicații grafice standard cum ar fi arhivatorul, calculatorul, etc.

- http://packages.gentoo.org/package/kde-base/kdewebdev-meta[kde-base/kdewebdev-meta] : Unelte pentru dezvoltare și creare aplicații WEB.

*Localizarea*

Pentru http://wiki.gentoo.org/wiki/Localization[localizare] în KDE
instalați kde-base/kde-l10n. Dacă doriți suport pentru o singură limbă
aleasă de dumneavoastră, definiți LINGUAS USE flag pentru limba
română:

Editare fișier '/etc/portage/make.conf':

....
LINGUAS="ro"
....

[source,bash]
----
root # emerge --ask kde-l10n
----

Pentru pachetele de localizare în
http://packages.gentoo.org/package/kde-base/kdepim-meta[kde-base/kdepim-meta]
trebuie să instalați

http://packages.gentoo.org/package/kde-base/kdepim-l10n[kde-base/kdepim-l10n].

http://packages.gentoo.org/package/app-office/calligra[app-office/calligra]
are pachet de localizare propriu de asemenea, http://packages.gentoo.org/package/app-office/calligra-l10n[app-office/calligra-l10n].

*Configurare*

*Serviciul de încărcare*

Instalarea lui KDM ca manager desktop.

[source,bash]
----
root # emerge --ask kde-base/kdm
----

Setați KDM ca manager de afișare inițial:

Editare fișier '/etc/conf.d/xdm:'

....
DISPLAYMANAGER="kdm"
....

Pentru a porni KDE automat la încărcarea sistemului, adăugați xdm la
privilegiul de rulare:

[source,bash]
----
root # rc-update add xdm default
----

Pentru a porni KDE acum rulați:

[source,bash]
----
root # /etc/init.d/xdm start
----

*Software adițional*

*Widgeturi*

Multe widget-uri folositoare le puteți găsii în pachetul
kde-base/kdeplasma-addons:

[source,bash]
----
root # emerge --ask kdeplasma-addons
----

==== Mediul grafic XFCE

*Introducere*

http://www.xfce.org/[Xfce] este un mediu grafic rapid și ușor pentru
sistemele de operare asemănătoare Unix. Este creat pentru
productivitate, este foarte configurabil și în același timp urmează
specificațiile http://www.freedesktop.org/[Freedesktop] .

Spre deosebire de mediile grafice mai ”greoaie”, cum ar fi
http://www.gnome.org/[Gnome] sau http://www.kde.org/[KDE], Xfce
folosește foarte puține resurse. În plus, oferă modularitate
excepțională și mai puține cerințe; folosește mai puțin spațiu pe
hard disk și se instalează mai rapid.

Acest ghid nu doar că vă va arăta cum să instalați un mediu grafic
minimal XFCE, dar vă va oferii posibilitatea de a vă crea un mediu
desktop complet având în prim plan filosofia Xfce: ușor, rapid și
modular.

Ultima parte a acestui ghid afișează câteva comenzi care trebuiesc
rulate după ce am făcut actualizare la ultima versiune XFCE, așadar
folosiți aceste comenzi dacă faceți update de la o versiune mai veche
la cea curentă.

*Instalare Xfce*

Asigurați-vă că aveți configurat xorg corect conform documentației:
[chap:Ghid-de-configurare].

Apoi verificați USE flags în /etc/portage/make.conf; probabil va
trebui să aveți setate cel puțin următoarele: USE="-gnome -kde
-minimal -qt4 dbus jpeg lock session startup-notification thunar udev
X".

qAcum că am setat variabilele în /etc/portage/make.conf, este
timpul să instalăm Xfce.

[source,bash]
.Instalare Xfce
----
# emerge -av xfce4-meta
----

Următorul pas, adăugați numele de utilizator la grupurile cdrom, cdrw,
și usb, ca să monteze dispozitive precum camera, dispozitive virtuale
și dispozitive USB.

[source,bash]
.Atribuirea utilizatorului unui grup hardware
----
(înlocuiți username cu numele dumneavoastră de utilizator)
# for x in cdrom cdrw usb ; do gpasswd -a username $x ; done
----

Apoi actualizați variabilele de mediu:

[source,bash]
.Actualizarea variabilelor de mediu
----
# env-update && source /etc/profile
----

Veți avea de asemenea nevoie de un terminal grafic ca să lucrați în
noul dumneavoastră mediu grafic.

x11-terms/xfce4-terminal este o alegere bună, și este conceput special
pentru mediul Xfce. Instalați terminalul folosind comanda:

[source,bash]
.Instalare terminal
----
# emerge x11-terms/xfce4-terminal
----

*Configurare Xfce*

Acum că Xfce este instalat, va trebui să îl setăm ca sistem grafic
primar pentru a porni când dăm comanda startx. Ieșiți din root shell
și logați-vă ca utilizator.

[source,bash]
.Setare Xfce ca sistem grafic implicit
----
$ echo "exec startxfce4" > ~/.xinitrc
----

NOTE: Dacă aveți ConsoleKit instalat, ~/.xinitrc ar trebui să conțină
exec startxfce4 --with-ck-launch. În mod contrar, anumite
aplicații ar putea să nu funcționeze. Posibil să trebuiască să
adăugați consolekit la nivelul de rulare implicit prin rularea
următoarei comenzi ca root: rc-update add consolekit default.

Acum puteți intra în noul mediu grafic prin comanda startx.

[source,bash]
.Pornire Xfce
----
$ startx
----

Felicitări, bine ați venit în noul dvs mediu grafic XFCE.

*Sesiune și pornire la încărcarea sistemului*

Dacă ați instalat (sau plănuiți să instalați) aplicații Gnome sau KDE
precum K3b, nautilus, kmail, evolution, etc. Ar trebui să vă asigurați
că Xfce pornește serviciile necesare pentru ca aceste aplicații să
funcționeze. Navigați la Menu --> Settings --> Sessions & Startup. Pe
opțiunea "Advanced", selectați căsuța implicită. Acest lucru ar putea
să îmbunătățească timpul de pornire al mediului Xfce, dar crește
timpul de încărcare pentru aplicațiile KDE și Gnome.

Xfce poate să vă salveze setările sesiunii și programele care rulează
din Tab-ul General în meniul Sessions & Startup. Pot fi salvate
automat când dați logout, sau Xfce vă poate întreba de fiecare dată
când ieșiți din mediul grafic. Această opțiune este foarte folositoare
atunci când configurați greșit ceva în mediul Xfce. Ați șters un panou
din greșeală? Selectați "No" când sunteți întrebat dacă vreți să
salvați setările din sesiunea curentă, și data viitoare când porniți
Xfce, vechile setări vor fi restaurate. Vreți ca aplicațiile preferate
precum navigatorul de internet, terminal și email să fie lansate în
mod automat când vă logați? Salvați sesiunea înainte de a vă de loga.

*Logare în modul grafic*

Vă amintiți când am adăugat startxfce4 la '~/.xinitrc'? Tot ceea ce
trebuia să faceți ca să intrați în mediul grafic era să dați comanda
*startx*. Acest lucru este în regulă dacă preferați încărcarea
sistemului și logarea în mod text, dar haideți să folosim un manager
grafic care să încarce în mod automat Xfce la încărcarea sistemului
(ca să vă puteți loga în modul grafic).

Mai întâi, haideți să ne asigurăm că Xfce se încarcă la boot.

[source,bash]
.Adăugare xdm la nivelul de execuție implicit
----
# rc-update add xdm default
----

Nu am terminat încă. Trebuie să alegem un manager pentru mediul grafic
(Display Manager) și să setăm variabilele corespunzătoare.  Deși sunt
câteva opțiuni în Portage, pentru acest ghid, folosim LXDM.

[source,bash]
.Instalare LXDM
----
# emerge –av lxdm
----

Pentru a edita variabila DISPLAYMANAGER mergem în '/etc/conf.d/xdm'.

Editare '/etc/conf.d/xdm'

....
DISPLAYMANAGER="lxdm"
....

LXDM poate porni automat sesiune XFCE dacă adăugați XSESSION="Xfce4"
la /etc/env.d/90xsession.

[source,bash]
.Setări XSESSION
----
# echo XSESSION=\"Xfce4\" > /etc/env.d/90xsession
# env-update && source /etc/profile
----

*Upgrade XFCE*

Dacă faceți upgrade la XFCE de la o versiune anterioară versiunii 4.x,
va trebui să ștergeți cache-ul sesiuni și profiles, deoarece sunt
incompatibile cu noile versiuni care apar. Pentru fiecare utilizator
(dacă aveți mai mulți), rulați următoarele comenzi.

[source,bash]
.Ștergerea sesiunii vechi și cache
----
$ rm -r ~/.cache/sessions
$ rm -r ~/.config/xfce*
$ rm -r ~/.config/Thunar
----

Utilizatorii vor avea o nouă interfață, dar vor pierde vechile setări
personalizate. Din păcate momentan nu există o metodă de a migra
setările de la o versiune Xfce la alta.
